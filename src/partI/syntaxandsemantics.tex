\newcommand{\code}[1]{\texttt{#1}}

\documentclass[11pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{qtree}
\usepackage{booktabs}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{rotating}
\renewcommand{\lstlistingname}{Snippet}
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}%
\usepackage[nounderscore]{syntax}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Ege Ã–zkan}
\title{Fluxion Language Specification \\ \large{0.1}}
\def\rot{\rotatebox}

\begin{document}


\newcommand{\diff}[2]{\ensuremath{\frac{\text{d}}{\text{d}#1} \left(#2\right)}}
\newcommand{\sdif}[2]{\ensuremath{\frac{\text{d}#1}{\text{d}#2}}}
\newcommand{\pdif}[2]{\ensuremath{\frac{\partial}{\partial #1} \left(#2\right)}}
\newcommand{\spdif}[2]{\ensuremath{\frac{\partial #1}{\partial #2}}}
\newcommand{\term}[1]{\ensuremath{\left(#1\right)}}
\newcommand{\oftype}{\ensuremath{\in^\text{T}}}
\newcommand{\intx}[1]{\ensuremath{\int \left(#1\right) \text{d}x}}
\newcommand{\iscons}{\ensuremath{\oftype \mathbf{C}}}
\frontmatter
\maketitle



\tableofcontents
\newpage


\chapter{Introduction}
\vspace{1em}
\begin{quotation}
This chapter includes the design philasophy of and concepts behind the Fluxion Language, and a defence of the Fluxion Language, that is, why it is needed.
\end{quotation}

\newpage
\section*{A Defence of Fluxion}

First thing one has to understand when it comes to language is its usefulness. As the readers may ask, \textit{why} should Fluxion exist? Don't we already have many scientific programming langauges like Python or Julia?\\

The answer to these questions can be given twofold: First, languages live and breath alongside with their ecosystem, even though their existence might be meaningful without a certain use case, and some even develop use cases they are originally not created for, in many cases, languages with a clear goal are easier to design.\\

Domain Specific Languages, are languages created to answer problems arising from a domain. Fluxion is such a language, its chief primary concern is to create a language, that can adequetly represent mathmatical constructs and expressions from many differing fields, to simplify, solve or to manuplate these constructs for the benefit of the users, who may wish to use Fluxion in their systems for a variety of purposes. These may range from pedogocial concerns, such as to teach pupils about certain mathematical concepts to proving actual mathematical problems.\\

When it comes to languages like Python, Julia or even Matlab, though they are useful, they are far to complex to be simple enough for users to actually engage with the symbolic mathematical underlayings of formulas, theorems and proofs. Fluxion aims to be simpler, much closer to mathematical notation, while still retatining \textit{some} but not all of their power. Fluxion does not aim to be a general purpose programming language. It does not even aim to be \textit{a} programming language. Fluxion is a Symbolic Computation Language, and it aims to excel at that one field.\\

Second, Fluxion does not aim to replace these languages, though some users will benefit it from it, to such a degree that in some use cases, they may prefer Fluxion, Fluxion will be written in such a way that it can be embedded and itnerloop with many of these languages, which will allow users to concantrate on problems and expressions like never before.\\

When designing Fluxion, first aim was to create a language that is easy to understand, extremely close to mathematical notation even if it went against previously established conventions of Computer Science, or if it adhered to conventions lesser known, this allows people litterate in Mathematics to easilly pick up Fluxion.\\

The second aim was to make sure that mistakes were limited. For instance, unlike many other languages, star imports does not exist in Fluxion to avoid namespace cluttering, in the reverse side of the import, module members are by default private, and must be exported explicitly using the \code{export} keyword.\\

Third aim of the Fluxion's \textit{design} is for it to be extendable. Using the \code{introduce} keyword, users and introduce Fluxion new \textit{contexts}, that can be about different domains of science using mathematics. A Physics domain may introduce Physics related constants and functions, a Mechanics domain may introduce functions and constants related to the mechanical engineering. This allows Fluxion to be tailored towards whatever purpose the user wishes it to be.

Fourth and final aim of the Fluxion is to be a free and open source alternative to the already established systems that are not as readilly as accessible or perhaps extendable as the Fluxion language itself.

\subsection*{Fluxion is not a Programming Language}

Fluxion is not a programming language. It is a symbolic computation language. However, this specification will refeer to the language as \textit{the Fluxion Language} for keeping things short.

\subsection*{the Name Fluxion}

Fluxion was the original name given to the instantenous rate of change of time sensitive function (or a Fluent Quantity, a \textit{Fluent}) by Sir Isaac Newton\cite{fluxionname}. In essance, Fluxion is an obscure term for derivatives\cite{collins}. Given that Fluxion arised from a Clojure program that was made to take derivatives, I felt it is a good name as any to give it.

\section*{Contents of the Specification}

Subsequent chapters of this specification will talk about different components of Fluxion. Each chapter will talk about a component, its syntax, semantics and behaviour. Syntaxes of these components will be expressed via the Extended Backus-Naur Form\cite{ISO14977} with very minor augmentations. \\

Next chapter contains the lexical structure of the language via Extended BNF, including the operators of the language, statements, expressions and literals. Third hapter contains these basic literal expressions, as well as the type system of Fluxion. Fourth chapter contains the operations on these literals. Chapter five discusses assignment and function definitions as well as built-in functions of the language. Chapter six discusses reductions, chapter seven discusses differentiation of various algabraic data types and finally, chapter eight discussess the various statements, such as \code{introduce} and \code{in} the language has. \\

This is the first part of a two parter language specification. As such, the standard library facilities will be introduced in the second part of this specification. Implementation of the standard library is necessary for a complete implementation of the Fluxion language, however, a minimal implementation may leave it out.

\section*{General Mathematical Notation}

Although Extended Backus Naur Form is well defined, parts of this specification will have to relly on more esoteric notation most notably, in mathematical expressions, $u \oftype \mathbf{C}$ will be used, the $\oftype$ symbol is used to express that this variable is of a specific Fluxion data type, symbols for datatypes are:

\Tree [.$\mathbf{F}$ [.$\mathbf{C}$  {Numbers \\$\mathbf{N}$} {Matrices \\$\mathbf{M}$} ] {Sets \\$\mathbf{S}$} {Sequences \\$\mathbf{R}$} ]

The $\mathbf{C}$ super type has the ability to be multiplied with unbound variables such as $x$.

\mainmatter
\part{Fluxion Core \\ \large{Fundamental Features of Fluxion}}

\chapter{Grammar}
\vspace{1em}
\begin{quotation}
This chapter includes the relevant grammar for statements, expressions and literals of the Fluxion language in Extended Backus-Naur Form.
\end{quotation}
\newpage


\section{Notation}

The notation included in this specification is ISO14977 Extended Backus-Naur Form, with the addition of the kleen-star \syntax{<a>*}, this symbol is used in place of the \syntax{\{<a>\}}, and represents that a certain lexeme may be repeated zero or more times. 

\section{Common Lexical Units}

Below are some lexemes, either in description, or in extended BNF that will be used as the building blog of more complex lexemes. first of all, let us define some production rules informally:

\begin{description}
\item[\synt{letter}] As it is used in the ISO14977, an English character within the ASCII, lowercase or uppercase.
\item[\synt{unicode}] A character that is either a \code{letter} or any unicode string that is not an operator.
\item[\synt{digit}] As it is defined in the ISO14977, a digit is a base ten numeral between 0 and 9.
\item[\synt{space}] Space, or more formally the ASCII character number thirty two.
\item[\synt{tab}] Tab, or more formally ASCII character number nine.
\item[\synt{EOF}] End of file character. May also be substituted for end of string.
\item[\synt{EOL}] End of line character.
\end{description}



\section{Literals}

Literals are the rough equivalents of rvalues in the C programming language. They are used to define "types".

\subsection{Boolean Literals}

\begin{grammar}
<boolean> := `True' | `False'
\end{grammar}

\subsection{Numerical Literals}

\begin{grammar}

<unsigned> := <digit> [, <digit>*]

<integer> := [<sign>], <unsigned>

<decimal> := <integer>, `.', <unsigned>

<imaginary> := <number>, <sign>, <number>, `i'

<number> := <decimal> | <integer> | <imaginary>
\end{grammar}

\subsection{Sets and Enumerables}

Sets and Enumerables share the same grammar they differ on semantics. Therefore, both will share the \synt{set} production rule.

\begin{grammar}
<finite> := `\{', <expression>*, `\}'

<builder> := `\{', <identifier>, '|', <logical\_condition>, `\}'

<set> := <finite> | <builder>
\end{grammar}

\subsection{Sequences}

Sequences are either built when \synt{finite} meets a condition or with their own notation.

\begin{grammar}
<sequence> := <finite> | ([<finite>], <identifier> `->' <expression>)
\end{grammar}

\subsection{Matrices and Vectors}

Vectors are subset of Matrices, so much so that, there is no special production rule for vectors.

\begin{grammar}
<row> := <expression>, (<whitespace>, <expression>)*

<matrix> := `[', <row>, (`|', <row>)*, `]'

\end{grammar}

\subsection{General Literal Grammar}

\begin{grammar}
<literal> := <boolean> | <number> | <set> | <matrix> | <sequence>
\end{grammar}

\section{Operators}

\subsection{Binary Operators}

\begin{grammar}

<algebraic\_operator> := `+' | `-' | `/' | `*' | `^' | `->' | `_' 

<comperasion\_operator> := `<' | `>' | `<=' | `>=' | `\\=' | `='

<logical\_operator> := `|' | `in' | <comperasion\_operator>

<hybrid\_operator> := `&'

<operator> := <algebraic\_operator> | <logical\_operator> | <hybrid\_operator>

\end{grammar}

\subsection{Unary Operators}

\begin{grammar}
<sign> := `+' | `-'

<prefix> := <sign> | `\\'

<postfix> := `'' | `!'

<unary\_operator> := <prefix> | <postfix>
\end{grammar}


\synt{hybrid\_operator}s are named as such as they can either be parsed as \synt{logical\_operator}s or as \synt{comperasion\_operator}s depending on the literals they are used with. In cases where ambiguity can arise, their algebraic versions have precedence.

\section{Variables and Expressions}

\begin{grammar}
<identifier> := [<identifier>, `::']<letter>, <unicode>*

<function> := <identifier>, `(', (<variable> | <literal> | <expression> | <logical\_condition> , `)'

<variable> := <identifier> | <function>

<cardinality> := `|', <expression>, `|'

<expression> := <cardinality> | [<prefix>], (<literal> | <variable>) [, <operator>, <expression>], [<postfix>]

<logical\_condition> := [`\\'], (<boolean> | <variable>) [, <logical\_operator> <logical\_condition>]

<assignment> := <variable>, `:=', <expression>
\end{grammar}

Here the \synt{function} production rule covers the function definition, as well as the function calls.

\section{Statements}

\begin{grammar}

<introduce> := "introduce", <identifier>

<solve> := `?', <expression>

<export> := `export', <identifier>, (`,' <identifier>)*

<statement> := <solve> | <introduce> | <export>

\end{grammar}

\section{General Program Grammar}

\begin{grammar}
<line> := <expression>*, EOL

<multiline\_comment> := `;*', <unicode>*, `*;'

<single\_comment> := `;;', <unicode>*, EOL

<multiline> := <line>, (<tab> | (<space> <space>) <line>)*

<unit> := <multiline> | <statement> | <assignment>

<program> := (<unit> | <comment>)*, EOF

\end{grammar}

Multiline statements can be achived by putting two spaces or a tab character in a line, in such case, programs treat this line as the continuation of the previous line.

\chapter{Fluxion's Type System}

\vspace{1em}
\begin{quotation}
This chapter includes the explanation of the Fluxion's type system from a programming language perspective.
\end{quotation}
\newpage


\section{An Overview of the Fluxion's Type System}

Fluxion is a dynamically typed language. Where the type of a variable is inferred by the language. Semantics of the operators change depending on which types they are acting upon in a given context. \\

All Fluxion types are immutable. As such, variables and literals when passed to functions, only pass by reference and never by value.\\

Fluxion has five main types. \code{boolean}, \code{number}, \code{set}, \code{matrix} and \code{sequence}. Of these five types, \code{number} is split into \code{integer}, \code{decimal} and \code{imaginary}; a subset of \code{set} types are \code{Enumerable} types and a subset of \code{matrix} types are \code{vector}s.  \code{number} and \code{matrix} types can interract directly within an expression depending on the circumstances (which will shortly be described). Members of \code{sequence}s and \code{enumerable}s can also be called upon to interract with \code{number} and \code{matrix} types, however, \code{boolean} types cannot interract with other types directly. Therefore, \code{number}, \code{set} and \code{matrix} types are called \textit{algebraic} types.

\subsection{Unbound Variable}

Since Fluxion is a Symbolic Computation Language, users may wish to leave variables without definition. In such cases, it is not guranteed what a variable may represent. Such variables are called \textit{Unbound variables}. If the variable \code{x} is undefined, the expression \code{x\^{\null}2 + 2} is still a valid expression.

\subsection{Associated Grammar}

Each Fluxion literal type can be produced by using an associated production rule. Types that adhere to the same production rules are special cases of their more general types.

\begin{table}[ht]
\centering
\caption{Grammar rules associated with each type.}
\begin{tabular}[t]{llc}
\hline
& Rule &Relevant Section\\
\hline
\code{boolean} & \synt{boolean} & \S 2.3.1 \\
\code{number} & \synt{number} & \S 2.3.2 \\
\code{integer} & \synt{integer} & \S 2.3.2 \\
\code{decimal} & \synt{decimal} & \S 2.3.2 \\
\code{imaginary} & \synt{imaginary} & \S 2.3.2 \\
\code{set} & \synt{set} & \S 2.3.3 \\
\code{enumerable} & \synt{set} & \S 2.3.3 \\
\code{sequence} & \synt{sequence} & \S 2.3.4 \\
\code{matrix} & \synt{matrix} & \S 2.3.5 \\
\code{vector} & \synt{vector} & \S 2.3.5 \\
\hline
\end{tabular}
\end{table}%


\section{Booleans}

Fluxion has two boolean values, \code{True} and \code{False}. These values may arise from logical operations. Unlike many languages, algebraic values themselves do not carry any significance in terms of boolean values.

\section{Numbers}

Numeric types are types that carry numeric values. They can be decimals, integers or imaginary numbers. A numerical literal written without a sign is presumed to be positive.

\subsection{Integers}

Integers are whole numbers. Fluxion allows an integer value to be between $-(2^{64} - 1)$ and $2^{64} - 1$. Trying to assign a variable to an integer literal above this number, or attempting to operate on this number will result in an exception.

\begin{lstlisting}[caption={Example integers},captionpos=b]
32
-23
0
\end{lstlisting}

\subsection{Decimal}

Decimals are numbers with a decimal point. They must be stored as fractions of integers within the language, thus allowing for high precision and easier reduction of expressions.

\begin{lstlisting}[caption={Example decimals},captionpos=b]
3.12
+4.234
-3.12
\end{lstlisting}

\subsection{Imaginary numbers}

Imaginary numbers are created by summing a number with another number multiplied with $i = \sqrt{-1}$ This also makes \code{i} a reserved keyword. If \code{a := b + c*i}, \code{b} is called the real part and \code{c} is called the imaginary part. Both \code{a} and \code{b} can take any value their type allows. (if \code{a} is an \code{integer}, it can be between negative and positive $2^{64} - 1$)

\begin{lstlisting}[caption={Example imaginals},captionpos=b]
3 + 2i
a + b*i
-3 - 1i
\end{lstlisting}

\subsection{Reserved Numerals}

Users cannot write some numerals themselves, these numerals may be needed to explain complex topics such as cardinality of infinite sets, irrational numbers, or function convergence.

\subsubsection{Irrational Numerals}
Irrational numbers are undefinable by normal user programs in Fluxion. However, special Irrational numbers that are often used in math, namely $\pi, \tau$ and $e$ are predefined in the language as \code{pi}, \code{tau} and \code{euler}. Functions that act on these values are hardcoded to resolve them in mathematically correct ways.\\

For instance, \code{sin(pi)} resolves to \code{0} and \code{ln(euler)} resolves to \code{1}. In expressions where such resolutions are impossible these variables are retained as variables. For more information, please refeer to \S 6.1.2.

\subsubsection{Cardinality of Infinite Sets}

Cardinality of countably infinite sets, that is for a set $S$, if $|S| = |\mathbb{N}|$ that set is told to be countably infinite, as such, to represent this cardinal, the literal \code{countable} is used. It is equivalent to $|\mathbb{N}| = \aleph_0$. \\

Cardinality of uncountably infinite sets is said to be \code{uncountable}, which is mathematically equivalent to any cardinal numeral larger than $\aleph_0$.

\section{Matrices}

A matrix consists of rows and columns. A matrix of $n$ rows and $m$ columns is told to be a matrix of size $m \times n$. In Fluxion, matrices may be as big as the memory allows. Moreover, matrices may hold values of arbitary types, including other matrices.

\begin{lstlisting}[caption={An example matrix},captionpos=b]
[1 2 3 | a b c | (12 + a) | (13 + c) | 3]
\end{lstlisting}

\subsection{Vectors}

Vectors are Matrices of dimension $m \times n$ where at least one of $m$ or $n$ equals one. Vectors can be horizontal or vertical.

\begin{lstlisting}[caption={Example vectors},captionpos=b]
[1 2 3]
[1 | 2 | 3]
\end{lstlisting}

\section{Sets}

Sets are container types that may be infinite or finite. They can be either defined using set builder notation, or by putting elements inside curly brackets. Sets are unorderdered, therefore, one cannot get elements outside a list. But one can check if an element is inside a list, sets also cannot contain two elements that are equal.

\begin{lstlisting}[caption={Example vectors},captionpos=b]
{1, 2, 3} ; A finite set.
{} ; An empty set.
{x | x in dN} ; A set with set builder notation.
\end{lstlisting}

\subsection{Enumerables}

Enumerables are special lists, they are either lists that are finite or countably infinite. A set is said to be countably infinite if its members can be mapped one to one with the set of natural numbers. More formally, Enumerables are sets that are enumaratable, for this reason, Enumerables are ordered.

\subsection{Predefined Sets and Enumerables}

Fluxion programming language comes built-in with certain sets and Enumerables. First of these is the \code{units} enumerable, which contain first three base vectors in order, $\vec{i}$, $\vec{j}$ and $\vec{k}$.

\subsubsection{Number Sets}

More usefully, Fluxion comes predefined with sets that represent number sets in math, these are called \textit{domains} (domain of natural numbers, etc.). Some of these, ones that can be mapped to natural numbers via bijection are also Enumerables.

\begin{table}[ht]
\centering
\caption{Domains, their Fluxion equivalents and their enumeration method as Enumerables, if it exists.}
\begin{tabular}[t]{lll}
\hline
& Variable & Enumaration\\
\hline
$\mathbb{N}$ & \code{dN} & $n \rightarrow n$\\
$\mathbb{Z}$ & \code{dZ} & $\{0, -1, 1, -2, \hdots\}$ \\
$\mathbb{Z^+}$ & \code{dZp} & $\{1, 2, 3, 4, 5, \hdots\}$ \\
$\mathbb{Z^-}$ & \code{dZn} & $\{-1, -2, -3, \hdots\}$ \\
$\mathbb{Q}$ & \code{dQ} & \S 10.3.1 \\
$\mathbb{Q^-}$ & \code{dQn} & \S 10.3.2 \\
$\mathbb{Q^+}$ & \code{dQp} & \S 10.3.3 \\
$\mathbb{R}$ & \code{dR} & -- \\
$\mathbb{C}$ & \code{dC} & -- \\
\hline
\end{tabular}
\end{table}%

\section{Sequences}

Sequences are container types that are enumarated. They can contain the same element more than once. They either come into existence when the curly bracket syntax is used with a repeating element or with their own special notation.

\begin{lstlisting}
a_sequence := {1, 2, 2}
an_enumarable := {1, 2, 3}
;; Underneath is the fibonacci!
another_sequence := {1, 1} x_n -> x_(n - 1) + x_(n - 2)
\end{lstlisting}

In this notation, the first finite sequence gives the first elements, then the next part is the production rule by which the next elements are created.

\chapter{Operations}
\vspace{1em}
\begin{quotation}
This chapter includes how operators act upon different variable types and the results of these operations.
\end{quotation}
\newpage

\section{Operator Semantics}

As established in \S 2.4, Fluxion has operators of many types, moreover, semantics of operators may change depending on the type of the value they are acting upon, akin to operator overloading.\\

Immutability of the Fluxion types mean that, when an operator act upon two expressions of any type, the result evaluates to another expression. This may be a algebraic value, an unbound variable, a smaller operation or the same operation.\\

Operations are the most top level expression, whose grammar is defined within \S 2.5 as \synt{expression}. Operations generally consist of one or more expressions (called operands) bound by an operator. These operators can be categorised in different ways: By their \textit{domain}, the type of variables they act on; by their \textit{arity}, the number of variables they take and by their \textit{position} with respect to the variables they take.\\

\begin{table}[]
\caption{A classification of operators in Fluxion}
\label{tab:operators}
\begin{tabular}{@{}llll@{}}
\toprule
Domain                     & Arity                                      & Position & Operators \\ \midrule
\multirow{4}{*}{Algebraic} & Binary                                     & Infix    &  \code{+}, \code{-}, \code{/}, \code{*}, \code{\^{\null}}, \code{\&}, \code{in}, \code{->}, \code{\_}         \\ \cmidrule(l){2-4} 
                           & \multicolumn{1}{c}{\multirow{3}{*}{Unary}} & Prefix   &  \code{+}, \code{-}, \code{\textbackslash}      \\
                           & \multicolumn{1}{c}{}                       & Postfix  &  \code{!}, \code{'}         \\
                           & \multicolumn{1}{c}{}                       & Midfix   &  \code{||}         \\ \midrule
\multirow{2}{*}{Boolean}   & Binary                                     & Infix    &  \code{<}, \code{>}, \code{<=}, \code{>=}, \code{=}, \code{\textbackslash =}, \code{\&}, \code{|}         \\ \cmidrule(l){2-4} 
                           & Unary                                      & Prefix   & \code{\textbackslash}          \\ \midrule
Scope & Binary & Infix & \code{::}, \code{:=}
\end{tabular}
\end{table}

As can be seen in Table \ref{tab:operators}, all Fluxion operators either take one operand, and hence they are \textit{unary} or they take two operands, and hence they are \textit{binary}. They either act upon algebraic and boolean types, although, same symbol maybe used for different meanings, and hence may take occupy more than one category. \\

All binary operators in Fluxion are also infix operators, which means they are placed in between the expressions they act upon, for instance, the algebraic sum operator \code{+} is placed between two expressions, as in \code{a + b}. Prefix unary operators are placed before the expression they act upon, for instance, boolean not operator \code{\textbackslash}, is used as \code{\textbackslash True}. On the other hand, postfix unary operators are placed following the expression they act upon, such as \code{a!}. \\

The midfix operator is the cardinality operator that is generally used for size and length related calculations. It is used such as \code{|a|}. The scope operators are operators that somehow modify the variable scope and are outside the scope of this chapter. (\S 5, \S 10) \\

Algebraic Operations (but not operators) can also be classified as homogeneous and heterogeneous operations. Homogeneous operations are either binary operations that act on the same types of operands, or unary operations, whereas the heterogeneous operations are operations that act between two different types of values. For instace, in mathematics, $12!$ and $\vec{a} \times \vec{b}$ is homogeneous, whereas $12\vec{a}$ is heterogeneous. \\

\section{Error Literals}

Error literals are literals that are created as a result of an mathematical error. When an error literal is evaluated, the language implementation must inform the user where it happened and if possible offer reasons begind it.

\begin{description}
\item[\code{Overflow}] An expression whose absolute value is bigger or equal to $2^{64}$.
\item[\code{Undefined}] Using an operator with types that does not support it. Dividing by zero.
\item[\code{Indeterminate}] Dividing zero by zero. May also arise from certain differentiations: \S 7.
\end{description}

\begin{lstlisting}[caption={Error Literal Examples}, captionpos=b]
> a := True + False
Undefined: + operator undefined between two boolean literals.
> 0/0
Indeterminate: 0/0 is an indeterminate form.
> 21!
Overflow
\end{lstlisting}

\section{Code Precedence}

Operations on numbers have precedence over operations on matrices, which has precedence over operations on sets, which has precedence on boolean operations. Operations within types are ordered within themselves.

\section{Homogeneous Operations}

\begin{table}[htbb]
\label{tab:operatordomains}
\begin{tabular}{ll}
\toprule
Domains & \\
\midrule
Numbers & \code{+}, \code{-}, \code{/}, \code{*}, \code{\^}, \code{'}, \code{||} \\
Integers & \code{!} \\
Imaginals & \code{\textbackslash} \\
\midrule
Sets & \code{+}, \code{-}, \code{in}, \code{||}, \code{\&}, \code{*} \\
\midrule
Matrices & \code{+}, \code{-}, \code{\&}, \code{||}, \code{\textbackslash} \\
Vectors & \code{*} \\
\midrule
Sequences & \code{+}, \code{||}, \code{\&}, \code{-}, \code{in} \\
\bottomrule
\end{tabular}
\caption{Domains of homogeneous algebraic operators, an homogeneous operator requires all of its operands to be of this type to work correctly.}
\end{table}

\subsection{Numerical Operations}

On numbers, precedence of operations is as follows:

\begin{enumerate}
\item Complex conjugate
\item Factorial
\item Differentiation
\item Exponantiation
\item Multiplication and Divison
\item Addition and Substraction
\end{enumerate}

\subsubsection{Common Operations}

Operations of addition (\code{+}) and substraction(\code{-}) work commonly across all numeric types. All numbers can be written of form $a + bi$, and hence, summation of \code{x := a + b*i} and \code{y := c + d*i} evaluate to \code((a + c) + (b + d)*i). Substriction of these terms \code{x - y}, evaluates to \code{(a - c) + (b - d)*i}\\

Operation of multiplication (\code{*}) is trivial mathematical multiplication when both sides are decimals or integers. When one of the sides are an imaginary number, real number part is distributed on both the imaginary and real parts of the number, evaluating into another imaginary number in most cases, such as $x(a + bi) = (ax + bxi)$ mathematically. When both sides are of the imaginary type, the multiplication is expanded mathematically $(a + bi)(c + di) = (ac + (a + b)i - bd) = (ac - bd) + (a + b)i$.\\

Division \code{/} works on a similar manner when both sides are real numerals. When the right hand side of the expression is real. When the left hand side is an imaginary number and the right a real number, distrbutive property is applied similar to multiplication. When the left hand side is \code{1} and right hand side is a complex numeral, the expression evaluates to the complex conjugate of the numeral.\\

Exponentiation \code{\^} is the trivial mathematical exponentiation for real numbers with the caveat that if a negative real number $a$ is exponantiated with a $x$ such that $-1 < x < 1$, $a^x$ is evaluated as $(-a)^x\sqrt{-1}$, which evaluates to $(-a)^xi$, or in Fluxion code format \code{(-a)\^{\null}x*i}. \\

However, for $x, z \in \mathbb{C}$ and $z = a + bi$, expression \code{x\^{\null}z} ($x^z$) evaluates to $x^a(\cos(b\ln|x|) + i\sin{(b\ln(x))})$ (\S 10.3.1). Moreover, since the logarithms are the inverse of the exponential function, their values are only unique to a value of $2k\pi$ and as such $e^{\ln{|a|} - 2k\pi}(e^{2k\pi}\cos(b\ln|x|) + e^{2k\pi}i\sin{(b\ln(x))})$  \cite{stack}, where any value of $K \in \mathbb{Z}$ is a valid answer to this question. As such, the Fluxion evaluates an exponantiation operation where the exponent is an imaginary number to a sequence of answers, ordered the same way as $\mathbb{Z}$ (\code{dZ}). \\

Differentiation operator \code{'}, always returns 0. As derivative of constants are 0. \\

Cardinality operator \code{||} acts as the absolute value operator for numbers, although trivial for real numbers, if the operand is an imaginary number of form $z = a + bi$, this \code{|z|} will evaluate to $\sqrt{a^2 + b^2}$. \\

\begin{lstlisting}[caption={Example usages of operations}, captionpos=b]
> 1 + 2
3
> 12 * 3
36
> 3i + 12 + 23 + 1i
35 + 4i
\end{lstlisting}

\subsubsection{Operations Exclusive to Integers}

The factorial operation, \code{!} is the equivalent to factorial in mathematics, and hence only evaluates with integer values. It is used such as \code{12!}, the highest evaluatable factorial is $20!$. Larger factorials \textit{may} evaluate to \code{Overflow}. \S 6.

\subsubsection{Operations Exclusive to Imaginals}

The complex conjugate operation, \code{\textbackslash}, which is used as \code{\textbackslash (3 + 5i)} evaluates to the complex conjugate of the imaginary numerals. \code{3 - 5i}.

\subsection{Matrix Operations}

\subsubsection{Common Operations}

Matrices and vectors share many operations together. \code{+} and \code{-} act by summing elements in the same cells if the matrices are of the same dimensions, otherwise informs the user. \\

\code{\textbackslash} takes the transpose of a matrix, $M^T$. While \code{||} Takes the norm of a matrix. \code{\&} is the matrix multiplication, otherwise known as cross product, $M \times N$ or $\vec{v} \times \vec{m}$.

\subsubsection{Operations Exclusive to Vectors}

When used between two vectors, \code{*} means the dot product of these vectors, $\vec{x} \cdot \vec{y}$.

\subsection{Set Operations}

Unlike other main types that has subtypes, all sets have a uniform set of operations that act on them. In sets, \code{+} acts as the join operation, while \code{-} is the disjoin operation, returning a set of elements not inside the other set. \code{\&} acts as the intersection operator and \code{*} acts as cartesian multiplication. \\

The cardinality operator, \code{||}, when used on finite sets, returns their length. When used on infinite sets, depending on its countability, it may either return \code{countable} \code{uncountable} (\S 3.3.4). \\

The contains operator, \code{in}, does not check for subsets when used with two sets. It still adheres to rules that will be explained in (\S4.5.3).

\subsection{Sequence Operations}

Sequences have two operations that differ from sets, they support \code{+}, used as concatanation, and \code{||}, which return the length of the sequence if the sequence is a finite sequence, or \code{countable} if it is infinite. (There are no uncountably infinite sequences.) \\

Other operators listed under Table \ref{tab:operatordomains} behave the same way as they do in set operations as shown in the Set Operations subsection (\S 4.4.3).

\section{Heterogenous Operations}

Heterogeneous operations are operations that can be performed between different types of values.

\subsection{Containment operator \code{in}}

The \code{in} operator, when its left-hand operand is any expression and when its right-hand operand is a set or a sequence, checks if the expression (or the the value it evaluates to) is inside the set or the sequence.

\subsection{Scalar Multiplication Operator \code{*}}

When one of the operands of the operator \code{*} is a numeric type, and the other a matrix type, the expression evaluates to the same matrix scalarly multiplied with the numeric type.

\section{Boolean Operations}

Boolean operations differ significantly from algebraic operations. To start with, they are classified differently. \textit{Pure Boolean Operations} act only on boolean literals, contrasted with \textit{Comparison Operators}, which act only on algebraic types, they themselves can be categorised further, \textit{Closed Comparison Operators}, operators that can compare only between the same algebraic types and \textit{Open Comparison Operators}, operators that can compare between all algebraic types.

\begin{table}[htbb]
\label{tab:booleanoperators}
\begin{tabular}{ll}
\toprule
Operation Type & Operators \\
\midrule
Pure Boolean & \code{\&}, \code{|}, \code{\textbackslash} \\
Open Comparison & \code{=}, \code{\textbackslash =} \\
Closed Comparison & \code{<}, \code{>}, \code{<=}, \code{>=} \\
\bottomrule
\end{tabular}
\caption{Operators used with different types of boolean operations.}
\end{table}

All of these operators, regardless of their types, evaluate to boolean literals \code{True} and \code{False}. Closed Comparison Operations, although allowed only within the same type, are also allowed between a main type and one of its subtypes, such as a \code{vector} and a \code{matrix}. Or between \code{decimals} and \code{integers}, but not between \code{imaginals} and other numeric types. \\

\subsection{Pure Boolean Operators}

Pure boolean operators are logical and (\code{\&}, $\land$), logical or (\code{|}, $\lor$) and logical not (\code{\textbackslash}, $\lnot$) they behave the same way as they do in mathematics. \\

When evaluating, binary pure boolean operators short-circuit.

\subsection{Open Comperasion Operators}

These operators are the equals (\code{=}) and not equals (\code{\textbackslash}) operators. By definition, if \code{a = b} evaluates to \code{True}, \code{a \textbackslash = b} will evaluate to \code{False}. \\

Equality operator, when both of its operands are not of the same type, evaluates to \code{False}, unless if one of them is an integer and the other a double of the same value as that integer, in which case, it evaluates to \code{True}. \\

The equality operator evaluates to \code{True} if both operands are:

\begin{itemize}
\itemsep0em
\item integers or decimals, and their values are equal.
\item imaginals and their respective imaginary and real parts are equal.
\item matrices of same dimensions and their elements in the same indices are equal.
\item sets and they contain the same elements, \textit{regardless} of their order, even if they are enumarables.
\item sequences and they contain the same elements in the same order.
\end{itemize}

\subsection{Closed Comperasion Operators}

These operators are the less than (\code{<}), greater than (\code{>}), and their ...or equal to contraparts (\code{<=}, \code{>=}) \\

These operators accept:

\begin{enumerate}
\item Two operands of the same type that are not matrices, imaginals or sequences.
\item An operand of a main type and an operand of who is a subtype of that main type.
\item An operand that is an integer, and another operand that is a double.
\item An operand that is an integer or a double, and another operand that is an irrational number.
\end{enumerate}

A less than operation evaluates to \code{True} when two operands are:

\begin{itemize}
\item doubles, integers or irrational numerals, and the left hand side has a smaller value.
\item sets and the left hand side is a strict subset of the right hand side.
\end{itemize}

A greater than operation evaluates to \code{True} when two operands are:

\begin{itemize}
\item doubles or integers, and the left hand side has a greater value.
\item sets and the left hand side is a strict superset of the right hand side.
\end{itemize}

Their ...greater than counterparts also evaluate to \code{True}, if an equals operation between these two operands would evaluate to \code{True}.


\chapter{Variables}

\vspace{1em}
\begin{quotation}
This chapter outlines the variable system of Fluxion, including function definitons. As well as outlining a list of built-in functions.
\end{quotation}
\newpage

Fluxion's assignment operator `:=' is used to assign variables and functions to expressions. In Fluxion, assignment can only occur in the top level scope of the program. \\

Functions are also special variables, defined using an identifier that must not be priorly assigned to any value.\\

When a variable is assigned to an expression, the variable's name in the global scope is now bound to that expression.

\section{Pure Variables}

Pure variables can be assigned to any expression. They can also be redefined, but the redefinitions do not affect other variables, because the expressions in the right hand side of the pure variable assignments are evaluated during assignment. For more information about evaluation, please see (\S 5.3). For instance:

\begin{lstlisting}
> r := 12
> a := r * 2
> a
| 24
> r := 128
> a
| 24
\end{lstlisting}

Attempting to use an unbound variable will result in an \code{Undefined} error literal to be emitted.

\begin{lstlisting}
> x := y + 2
| Undefined: Identifier "y" is not assigned.
\end{lstlisting}

\section{Functions}
Functions are special forms of variables with their own scope. Functions are evaluated lazily, when a function call occurs. When defining a function, right hand side is an expression, as in pure variables, but the left hand side must be of the form \code{f(x)} where \code{f} is a valid identifier and \code{x} must be of the form of a pure variable or a logical condition (used in partial functions) (\S 2.5), or a list of functions. \\

The variable defined in the left hand side of the function, when used in the right hand side, refeers to a currently unbound variable. For more information as well as the resolution of Function calls, see (\S 5.3.1). \\

Functions can also be assigned to other functions. But they may not return other functions.
\subsection{Partial Functions}

Partial functions are defined by defining more than one function with the same identifier, but with a logical condition using a variable name.

\begin{lstlisting}
f(x < 0) := 0
f(x >= 0) := 1
g(x, y < 0) := x * y
g(x, y >= 1) := x + y 
\end{lstlisting}

If a partial function is called with a value it is not defined for, an \code{Undefined} error literal is emitted.

\subsection{Function Domains}

Function domains are assumed to be in the real numbers unless specifically defined, however, domains of functions can be restricted by the usage of \code{f(x: S1) -> S2 := ...}, where \code{S1} and \code{S2} are sets. \\

\subsection{Unary Function Inverter Operation \code{\textbackslash}}

When the operator \code{\textbackslash} is used on a function, it evaluates to a function that is the inverse of that function. However, not all functions have inverses, hence, there are cases when this expression will evaluate to \code{Undefined} if the functions does not have a one-to-one mapping on its domain. \\

The calculated inverse function can be assigned to another function, for instance, if there exists a function \code{f}, \code{g(x) := \textbackslash f(x)} will assign \code{g(x)} to the inverse of \code{f(x)}, moreover, reverse functions can also be called directly, for instance, by \code{\textbackslash f(3)}. \\

The term \code{\textbackslash f(x)} is mathamatically equivalent to $f^{-1}(x)$.

\subsection{Binary Convergence Operator \code{->}}

\code{->} can be used for taking the limit of a function. \code{f(x -> 0)} takes the limit for 0, \code{f(x -> 0+)} takes the function's limit approaching from positive side, and \code{f(x -> 0-)} takes the functions limit from the left side.

\section{Expression Evaluation}

Expressions are evaluated by first resolving the variables used inside by refeering to the closest scope, and then reducing the expressions as per the reducing rules. In most cases, by evaluating the operations between types. \\

\subsection{Name Resolution}

Names are resolved by using the value of the variable name in the closest scope. If no such variable exists, the \code{Undefined} literal is emitted.

When evaluating pure variables, this scope is always the global scope, hence evaluation is easy. However, when evaluating a function, global scope might become another function:

\begin{lstlisting}
f(y) = y + 2
y = 2
g(x) = f(x + 2) + 4
g(y)
\end{lstlisting}

Here, when \code{g(y)} is called, first the \code{y} resolves to \code{2}, then the expression assigned evaluates to \code{f(2 + 2) + 4}, which reduces to \code{f(4) + 4}, \code{f(y)} is then called, where \code{y} resolves to \code{4} of the function call and not the \code{2} from global scope. Following which, \code{f(4)} evaluates to \code{4 + 2}, turning the expression into \code{4 + 2 + 4}, which finally reduces (in two steps) to \code{10}.

\section{Macros}

Macros are special functions that act on the semantic representation of the source code. They are defined using the extension facilities of the language. Macros cannot be defined by the Fluxion language itself. Fluxion does not come with any built in variables, but its standard library contains some.

\section{Built-in Functions}

Fluxion comes pre-equipped with multiple functions from various fields of mathematics to facilitate ease of use for the user for everyday mathematical tasks.

These functions are overlaid in Table \ref{utifunctions}. In this table, the arguments of the functions are translated to their equivalents as $x, y, z, t, u$ in order.

\begin{table}[httb]
\label{tab:utilfunctions}
\begin{tabular}{lll}
\toprule
Function & Equivalent & Domain \\
\midrule
\code{sum(from, to, sequence)} & $\sum_{x}^{y}z$ & $\{\forall x, y \in \mathbb{N}\land z \subseteq \mathbb{C} | y \geq x \} \rightarrow \mathbb{C}$\\
\code{prod(from, to, sequence)} & $\prod_{x}^{y}z$ & $\{\forall x, y \in \mathbb{N}\land z \subseteq \mathbb{C} | y \geq x \} \rightarrow \mathbb{C}$ \\
\code{isum(sequence)} & $\sum_0^{\infty}x$ & $\forall z \subseteq \mathbb{C} \rightarrow \mathbb{C} + \{-\infty, \infty, \texttt{Indeterminate} \}$ \\
\code{iprod(sequence)} & $\prod_0^{\infty}x$ & $\forall z \subseteq \mathbb{C} \rightarrow \mathbb{C} + \{-\infty, \infty, \texttt{Indeterminate} \}$ \\
\code{log(base, value)} & $\log_x{y}$ & $\mathbb{R^+} \rightarrow \mathbb{R}$\\
\code{ln(value)} & $\ln{x}$ & $\mathbb{R^+} \rightarrow \mathbb{R}$\\
\code{root(base, value)} & $\sqrt[x]{y}$ & $\mathbb{C} \rightarrow \mathbb{C}$\\
\code{sqrt(value)} & $\sqrt{x}$ & $\mathbb{C} \rightarrow \mathbb{C}$\\
\code{sin(x)} & $\sin{x}$ & $(-\infty, +\infty) \rightarrow [-1, 1]$\\
\code{cos(x)} & $\cos{x}$ & $(-\infty, +\infty) \rightarrow [-1, 1]$\\
\code{tan(x)} & $\tan{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | \frac{\pi}{2} + k \pi \} \rightarrow (-\infty, +\infty)$\\
\code{cot(x)} & $\cot{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | k \pi \} \rightarrow (-\infty, +\infty)$\\
\code{sec(x)} & $\sec{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | \frac{\pi}{2} + k \pi \} \rightarrow \mathbb{R} - (-1, 1)$\\
\code{csc(x)} & $\csc{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | k \pi \} \rightarrow \mathbb{R} - (-1, 1)$\\
\code{arcsin(x)} & $\sin^{-1}x$  & $[-1, 1] \rightarrow [-\frac{pi}{2}, \frac{\pi}{2}]$\\
\code{arccos(x)} & $\cos^{-1}x$ & $[-1, 1] \rightarrow [0, \pi]$\\
\code{arctan(x)} & $\tan^{-1}{x}$ & $ (-\infty, infty) \rightarrow (-\frac{pi}{2}, \frac{\pi}{2})$ \\
\code{arccot(x)} & $\cot^{-1}x$ & $(-\infty, infty) \rightarrow (0, \pi)$ \\
\code{arcsec(x)} & $\sec^{-1}x$ & $(-\infty,  -1] \cup [1, \infty) \rightarrow [0, \frac{\pi}{2}) \cup (\frac{\pi}{2}, \pi]$ \\
\code{arccsc(x)} & $\csc^{-1}x$ & $(-\infty,  -1] \cup [1, \infty) \rightarrow [-\frac{pi}{2}, 0) \cup (0, \frac{\pi}{2}]$\\
\code{Re(complex)} & $\Re(x)$ & $\mathbb{C} \rightarrow \mathbb{R}$\\
\code{Im(complex)} & $\Im(x)$ & $\mathbb{C} \rightarrow \mathbb{R}$\\
\code{gamma(value)} & $\Gamma(x)$ & $\{ \forall x \in \mathbb{\mathbb{C}} | \Re(x) > 0 \} \rightarrow \mathbb{C}$ \\
\code{floor(num)} & $\lfloor x \rfloor$ & $\mathbb{R} \rightarrow \mathbb{Z}$\\
\code{ceil(num)} & $\lceil x \rceil$ & $\mathbb{R} \rightarrow \mathbb{Z}$ \\
\code{modulo(base, num)} & $c := y \mod_x$ & $\forall y \in \mathbb{R}, x \in \mathbb{Z} \rightarrow \mathbb{C}$ \\
\code{even(num)} & $x = 0\mod_2$ & $\mathbb{Z} \rightarrow \left\lbrace \texttt{True}, \texttt{False} \right\rbrace$ \\
\code{gcd(x, y)} & $\gcd(x, y)$ & $\mathbb{Z^+} \rightarrow \mathbb{Z^+}$ \\
\bottomrule
\end{tabular}
\caption{Builtin functions.}
\end{table}




%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% TRANSFORMATIONS %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%





\chapter{Transformations}

\vspace{1em}
\begin{quotation}
This chapter discusses the concept of transformations, special functions that can act on functions and return functions with unbound variables, as well as providing a list of builtin transformations of the Fluxion language.
\end{quotation}
\newpage

Transformations are special functions. They can only be assigned to other functions, since they evaluate to function definitions. Fluxion provides a variety of builtin transformations as can be seen in Table \ref{tab:transformations}.

\begin{table}[httb]
\label{tab:transformations}
\begin{tabular}{ll}
\toprule
Transformation & Equivalent in Mathematics \\
\midrule
\code{diff(function, var)} & $\frac{\text{d}}{\text{d}y}x$ \\
\code{gradient(function)} & $\nabla f(x)$ \\
\code{taylor(function, value)} & Taylor expansion on value. \\
\code{maclaurin(function)} & Maclaurin expansion. \\
\code{defInt(function, var, from, to)} & $\int_{z}^u x dy$ \\
\code{int(function, var)} & $\int x dy $ \\
\bottomrule
\end{tabular}
\caption{A list of builtin transformations.}
\end{table}

The name transformation refeers to two facts, one is that these \textit{``functions"}, transform functions to other functions by transforming the internal representation of the functions themselves, and two; When viewed from a certain angle, differentiation is a linear transformation, and all of these functions are built upon differentiation.\\

\section{Differentiation Transformation}

Differentiation transformation is created by either using the \code{'} (the differentiation operator) on a function bound to a single variable (Otherwise evaluates to total derivative at that point.), or by using the \code{diff} function. \code{diff(function, variable)} takes the function to differentiate, and the variable to differentiate with respect to. Assume function \code{f} has a single variable (\code{x}) and function \code{g} has two, Table \ref{tab:differentiation} shows how the usage of these methods has equivalents in mathematics.

\begin{table}[httb]
\label{tab:differentiation}
\begin{tabular}{ll}
\toprule
Usage & Equivalent in Mathematics \\
\midrule
\code{f'} & $\frac{\text{d}}{\text{d}x}f$ \\
\code{g'} & Total derivative of $g$\\
\code{f'(x)} & $\left(\frac{\text{d}}{\text{d}x}f \right)(x)$\\
\code{k(z) := f'(z)} & $k(z) := \left(\frac{\text{d}}{\text{d}x}f \right)(z)$ \\
\code{diff(f, z)} & $\frac{\text{d}}{\text{d}z}f$ \\
\code{diff(f, x)} & $\frac{\text{d}}{\text{d}x}f$ \\
\code{diff(g, y}) & $\frac{\partial}{\partial y}g$\\
\bottomrule
\end{tabular}
\caption{Usage of differentiation transformation.}
\end{table}

Since this is a specification. Rules of differentiation the Fluxion standard comes with must also be listed. They will be listed in formal mathematical notation. Assume that any constant is etiher a Matrix or a Number unless an operation not supported by either is performed, or if specified explicitly.

\subsection{Rules of Differentiation}

\subsubsection{Simple Rules of Differentiation}

\begin{align}
\diff{x}{t + u} &\Rightarrow \sdif{t}{x} + \sdif{u}{x}\\
\diff{x}{tu} &\Rightarrow \sdif{t}{x}u + \sdif{u}{x}t\\
\diff{x}{u^n} &\Rightarrow nu^{n - 1}\sdif{u}{x}\\
\diff{x}{\frac{1}{u}} &\Rightarrow -\frac{1}{u^2}\sdif{u}{x}\\
\diff{x}{\frac{t}{u}} &\Rightarrow \frac{1}{u^2}\left(\sdif{t}{x} u - \sdif{u}{x}t\right)\\
\diff{x}{u^t} &\Rightarrow u^t \left(\sdif{t}{x}\ln{u} + \sdif{u}{x} \frac{t}{\ln{u}}\right) 
\end{align}

\subsubsection{Differentiation of Functions in General}

\begin{align}
\diff{x}{f(g(x))} &\Rightarrow \sdif{g}{x} \times \sdif{f}{x}\term{g(x)}
\end{align}

\subsubsection{Differentiation of Logarthmic Functions}

\begin{align}
\diff{x}{\log_u{t}} &\Rightarrow \frac{1}{\ln^2u} \term{\sdif{t}{x} \frac{\ln u}{\ln t} - \sdif{u}{x}\frac{\ln t}{\ln u}}\\
\diff{x}{\ln u} &\Rightarrow \sdif{u}{x} \frac{1}{\ln u}
\end{align}


\subsubsection{Differentiation of Trigonometric Functions}

\begin{align}
\diff{x}{\sin{u}} &\Rightarrow \sdif{u}{x} \cos{u}\\
\diff{x}{\cos{u}} &\Rightarrow -\sdif{u}{x} \sin{u}\\
\diff{x}{\tan{u}} &\Rightarrow \sdif{u}{x} \sec^2{u}\\
\diff{x}{\cot{u}} &\Rightarrow -\sdif{u}{x} \csc^2{u}\\
\diff{x}{\cot{u}} &\Rightarrow \sdif{u}{x} \tan{x} \sec{x}\\
\diff{x}{\cot{u}} &\Rightarrow -\sdif{u}{x} \cot{x}\csc{x}
\end{align}

\subsubsection{Differentiation of Inverse Trigonometric Functions}

\begin{align}
\diff{x}{\sin^{-1}u} &\Rightarrow \sdif{u}{x} \frac{1}{\sqrt{1 - u^2}}\\
\diff{x}{\cos^{-1}u} &\Rightarrow -\sdif{u}{x} \frac{1}{\sqrt{1 - u^2}}\\
\diff{x}{\tan^{-1}u} &\Rightarrow \sdif{u}{x} \frac{1}{1 + x^2}\\
\diff{x}{\cot^{-1}u} &\Rightarrow -\sdif{u}{x} \frac{1}{1 + x^2}\\
\diff{x}{\sec^{-1}u} &\Rightarrow \sdif{u}{x} \frac{1}{|x| \sqrt{x^2 - 1}}\\
\diff{x}{\csc^{-1}u} &\Rightarrow -\sdif{u}{x} \frac{1}{|x| \sqrt{x^2 - 1}}
\end{align}

\subsubsection{Differentiation of Integrals}

\begin{equation}
\diff{x}{\int_{u}^{v} f(x, t) \text{d}t} \Rightarrow f(x, v)\sdif{v}{x} - f(x, u) \sdif{u}{x} + \int_{u}^{v}  \spdif{f}{x} \text{d}t
\end{equation}

\section{The Gradient Transformation}
The gradient is a special way to perform multiple differentiation translations at once that results in a vector to be created. Using the gradient operator on a function $f(a_0, a_1, \dots, a_n)$. will result in:

\begin{align}
\nabla f &\Rightarrow \begin{pmatrix}
           \displaystyle\spdif{f}{a_1}\\[0.1em]\\
           \displaystyle\spdif{f}{a_2} \\
           \vdots \\
           \displaystyle\spdif{f}{a_n}
         \end{pmatrix}
\end{align}

\section{Taylor Transformation}

Taylor Transformation returns the taylor series expansion of a function using \code{sum} and a countable \code{enumerable}. Taylor transformations has two rules depending on the arity of the function, Taylor transformation itself is represented via $T_f(x)$, this notation reads as Taylor transformation of $f$ at point $x$.

\begin{align}
T_f(a) &\Rightarrow \sum_{n = 0}^{\infty} \frac{f^{(n)}(a)}{n!}(x - a)^n\\
T_f(a_1, a_2, \dots, a_d) &\Rightarrow \sum_{n_1, n_2, \dots, n_d = 0}^{\infty} \left[ \left[ \prod_{m = 1}^d (x_m - a_m)^{n_m} \right] \left[ \prod_{m=1}^d \frac{1}{n_d!} \right] \left[\left( \frac{\partial^{n_1 + \dots + n_d} f}{\partial x_1^{n_1} \dots \partial x_d^{n_d}} \right)(a_1, \dots, a_d) \right] \right]
\end{align} 

If the arity of the function $f$ is one with one argument $x$, equation 5.24 gives the Taylor Expension of the function, if the arity of the function $f$ is $d \geq 2$, with arguments $x_1, x_2, \dots, x_d$, then the equation 5.25 gives the taylor expansion of the equation at points $a_1, a_2, \dots, a_d$, such that $\forall i, x_i = a_i$.

\section{Maclaurin Transformation}

Maclaurin Transformation $M_f$ is a special version of the Taylor Transformation $T_f(a_1, a_2, \dots, a_d)$, such that $\forall i, a_i = 0$. This translates to:

\begin{align}
M_f &\Rightarrow \sum_{n = 0}^{\infty} \frac{f^{(n)}(0)x^n}{n!} \\
M_f &\Rightarrow \sum_{n_1, n_2, \dots, n_d = 0}^{\infty} \left[ \left[ \prod_{m = 1}^d (x_m)^{n_m} \right] \left[ \prod_{m=1}^d \frac{1}{n_d!} \right] \left[\left( \frac{\partial^{n_1 + \dots + n_d} f}{\partial x_1^{n_1} \dots \partial x_d^{n_d}} \right)(0, \dots, 0) \right] \right]
\end{align}

\section{Integration Transformation}

Integration is performed on a function using the \code{int} transformation. Indefinite version of which is sometimes called as the antiderivative, as it takes a function $f$ and returns another function $F$ whose derivative $F' = f$. However, this raises an issue, since $\forall c \in \mathbb{C}, \diff{x}{F(x) + c} = f(x)$ also. This $c$ is an indeterminate. For this reason, a special constant exists in Fluxion, \code{ic}.\\

\code{ic} is treated as 0 for operations. \\

\subsection{Solving an Integral}

Integrals are solved in multiple parts. First, an integral must be converted to a list possible factorings, consider an integral:

\begin{equation}
R(x) = \intx{t + u + v}
\end{equation}

This integral can be factored into different permutations. These permutations create the permuation list for $R$, $P_R$:

\begin{align}
\begin{split}
P_R =\Bigg\lbrace &\intx{t + u + v}, \intx{t + u} + \intx{v},\\
&\intx{t + v} + \intx{u}, \intx{u + v} + \intx{t},\\
&\intx{t} + \intx{u} + \intx{v} \Bigg\rbrace
\end{split}
\end{align}

Then, each $r \in P_R$, is ran through the solution algorithm, the steps of there are three steps of the solution algorithm, if one step fails, the other is tried, each step is ran first without reducing the expression, and then after reducing the expression. If all else fails, the integral is left as a closed form.:

\begin{enumerate}
\item Try to match the integral against one of the common forms.
\item Try to run the Euler's Formuler for the Integration of Trigonometric Functions.
\item Try to run the Risch algorithm on the integral.
\end{enumerate}

When all of this is done, sort the integrals in the list, first the open forms, then the closed forms. Then, sort each group with respect to their simpleness. The simpleness of an integral is determined as one over the sum of costs of that integral's elements. Costs of common functions are given in Table \ref{tab:costs}.

\begin{table}[httb]
\label{tab:costs}
\begin{tabular}{ll}
\toprule
Function Type & Cost ($c$) \\
\midrule
$\forall m \oftype \mathbf{N}, m$ & 1\\
$\forall m \oftype \mathbf{N}, mx$ & 10\\
$\forall m \oftype \mathbf{N}, mx^n$ &  50\\
$e^u$ & 100 \\
$a^u$ & 150 \\
Functions & 200 \\
Trigonometric Functions & 250 \\
Inverse Trigonometric Functions & 300 \\
$u^t$ & 350 \\
Other & 500\\
\bottomrule
\end{tabular}
\caption{A list of costs.}
\end{table}


\subsubsection{Integral Reductions}

Integral Reductions that are performed within the expressions inside the intregral are usual reductions in the Chapter 6, with the addition of the following special reduction:

\begin{align}
\intx{m\lambda} &\Rightarrow m \intx{\lambda} & \term{m \iscons \land \spdif{\lambda}{x} \neq 0}
\end{align}

Reductions that include the integral expression must be done after the integral expression is resolved.

\subsubsection{Common Forms}

When an integral expression matches to the expressions of the form in the left hand side of the arrow, its integral is the right hand side of the arrow.

\begin{align}
\text{Integral } (F) & \Rightarrow \text{Function } (f) & \text{Condition} \\
\intx{x^m} &\Rightarrow \frac{x^{m + 1}}{m + 1} + c & \term{m \oftype \mathbf{C}} \\
\intx{\frac{1}{x^m}} &\Rightarrow \frac{1 - m}{x^{m - 1}} &\term{m > 1}\\
\intx{\frac{1}{x}} &\Rightarrow \ln|x| + c\\
\intx{m^x} &\Rightarrow \frac{m^x}{\ln|m|} + c & \term{m \oftype \mathbf{C}}\\
\intx{m} &\Rightarrow mx + c &\term{m \iscons} 
\end{align}

\subsection{Integration with Euler's Formula}

This method is applied if and only if all functions are purely consisting of trigonometric functions. Once it is ensured all functions inside the integral are trigonometric, then, the rules in Equation 5.37 is used to convert all trigonometric functions, following this operations between them are evaluated and after the integration, they are converted back to their trigonometric equivalents.

\begin{equation}
\begin{split}
\text{Original Form} & \Rightarrow \text{ Converted}\\
\cos{u} &\Rightarrow \frac{e^{iu} + e^{-iu}}{2}\\
\sin{u} &\Rightarrow \frac{e^{iu} - e^{-iu}}{2i}\\
\tan{u} &\Rightarrow -i \frac{e^{iu} - e^{-iu}}{e^{iu} + e^{-iu}}\\
\cot{u} &\Rightarrow i \frac{e^{iu} + e^{-iu}}{e^{iu} - e^{-iu}}\\
\sec{u} &\Rightarrow \frac{2}{e^{iu} + e^{-iu}}\\
\csc{u} &\Rightarrow \frac{2i}{e^{iu} - e^{-iu}}
\end{split}
\end{equation}

\subsection{Risch's Algorithm}

Risch's Algorithm has never been implemented in its entirety. Fluxion's fullest version should attempt to implement this algorithm. Minimalistic implementations are free to actually skip this step.\\

When it comes to actually implementing the Risch's Algorithm, there are multiple algorithms that are put forward by different computer scientists, one of the most prominent, late Manuel Bronstein, presented a tutorial outlining an implementation of the Risch's Algorithm\cite{bronstein}. This tutorial may serve a good basis for any implementation of the Fluxion standard.

\section{Definite Integration}

Definite integrations work differently then indefinete ones, since it is easier to implement them. Fluxion expects any integral to evaluate to a value or \code{Indeterminate}.

%%%%%%%%%%%%%%
% REDUCTIONS %
%%%%%%%%%%%%%%


\chapter{Reductions}

\vspace{1em}
\begin{quotation}
This chapter includes how the Fluxion language reduces expressions to simpler expressions.
\end{quotation}
\newpage

Reductions comes in many shapes and forms, some act on simple operation expressions, whereas others may be able to actually reduce builtin functions. Therefore, the reduction rules are covered section by section. Reduction rules are described via mathematical formulae, the characters $\alpha$, $\beta$, $\lambda$ etc are used to describe any sort of expression unless otherwise specified. Also assume that any variables are numeric in types unless otherwise specified. A base expression, followed by a $\Rightarrow$ followed by the reduced expression. \\

The $\mathbf{M}, \mathbf{V}, \mathbf{S}, \mathbf{E}, \mathbf{A}, \mathbf{N}$ domains represent types of variables. (Matrices, vectors, sets, enumerables, sequences and numbers, respectivelly.) In addition to classic number domains. $a_T$ refeers to the type of an expression. Moreover, $a \in^T \mathbf{S}$ is used to describe that a is of type $\mathbf{S}$ \\

Moreover, not all of these reduction rules are valid for all the Fluxion types and in all cases, conditions for them are given with parantheses.

\section{Reductions on Simple Operations}

Assume that, $\alpha$ and $\beta$ are any expressions, moreover, assume that if $\alpha$ and $\beta$ are both vectors or matrices, $\gamma$ is their common integer divisor or $\exists \gamma \in \mathbb{C}, \gamma\alpha = \beta$. If not, $\gamma = 1$.


\begin{align}
\alpha\lambda + \beta\lambda &\Rightarrow \left( \frac{\alpha}{\gamma} + \frac{\beta}{\gamma}\right)\gamma\lambda & \left( \alpha_T = \beta_T, \alpha, \beta, \lambda \in^T \mathbf{M} \cup \mathbf{N} \right)\\
\alpha\lambda - \beta\lambda &\Rightarrow \left( \frac{\alpha}{\gamma} - \frac{\beta}{\gamma}\right) \gamma\lambda & \text{(Same as 6.1)}\\
\alpha\lambda^m \times \beta\lambda^n &\Rightarrow  \alpha\beta\lambda^{m + n} & \left( \alpha, \beta \in^T \mathbf{M} \cup \mathbf{N} \right)\\
\frac{\alpha\lambda^{m}}{\beta\lambda^{n}} &\Rightarrow \frac{ \alpha}{\beta}\lambda^{m - n} & \left(\lambda \neq 0, \alpha, \beta \in^T \mathbf{M} \cup \mathbf{N} \right)\\
\alpha^{\lambda}\beta^{\lambda} &\Rightarrow \left(\alpha\beta\right)^\lambda & \left( \alpha, \beta \in^T \mathbf{N} \right)\\
\frac{\beta!}{\alpha!} &\Rightarrow \left(\beta - \alpha\right)! & \left( \alpha, \beta \in^T \mathbf{N}, \alpha \leq \beta \right)\\
\frac{\beta!}{\alpha!} &\Rightarrow \frac{1}{\left(\beta - \alpha\right)!} & \left( \alpha, \beta \in^T \mathbf{N}, \alpha > \beta \right)
\end{align}

\section{Reductions on Functions}

\begin{equation}
f(f^{-1}(\lambda)) \Rightarrow \lambda
\end{equation}

\section{Reductions on Logarithmic Functions}

All variables must follow the domains of the functions.

\begin{align}
e^{\ln\lambda} &\Rightarrow \lambda\\
\alpha^{\log_\alpha\lambda} &\Rightarrow \lambda \\
\log_{\alpha}\lambda^\beta &\Rightarrow \beta \log_\alpha \lambda \\
\log_{\alpha}\lambda + \log_\alpha\beta &\Rightarrow \log_{\alpha} (\lambda\beta) \\
\end{align}

\section{Reductions on Trigonometric Functions}
All variables must follow the domains of the functions.
\begin{eqnarray}
\frac{\sin\lambda}{\cos \lambda} \Rightarrow \tan \lambda \\
\frac{\cos \lambda}{\sin \lambda} \Rightarrow \cot \lambda \\
\frac{1}{\sin \lambda} \Rightarrow \csc\lambda \\
\frac{1}{\cos \lambda} \Rightarrow \sec\lambda \\
\frac{1}{\tan\lambda} \Rightarrow \cot \lambda \\
\frac{1}{\cot \lambda} \Rightarrow \tan \lambda \\
\tan \lambda \cos\lambda \Rightarrow \sin \lambda \\
\cot \lambda \sin \lambda \Rightarrow \cos \lambda \\
\tan \lambda \csc \lambda \Rightarrow \sec \lambda \\
\cot \lambda \sec \lambda \Rightarrow \csc \lambda \\
\cos^2 \lambda + \sin^2 \lambda \Rightarrow 1 \\
2 \cos \lambda \sin \lambda \Rightarrow \sin \left(2 \lambda\right) \\
\cos^2 \lambda - \sin^2 \lambda \Rightarrow \cos \left(2 \lambda \right) \\
1 - 2\cos^2\lambda \Rightarrow \cos \left(2 \lambda \right) \\
2\sin^2\lambda - 1 \Rightarrow \cos \left(2 \lambda \right)
\end{eqnarray}

\section{Reduction on Inverse Trigonometric Functions}
All variables must follow the domains of the functions.
\begin{eqnarray}
\sin(\sin^{-1}\lambda) \Rightarrow \lambda \\
\cos(\cos^{-1}\lambda) \Rightarrow \lambda \\
\tan(\tan^{-1}\lambda) \Rightarrow \lambda \\
\cot(\cot^{-1}\lambda) \Rightarrow \lambda \\
\sec(\sec^{-1}\lambda) \Rightarrow \lambda \\
\end{eqnarray}


\section{Reductions on Gamma Function}

\begin{align}
\Gamma(\lambda) &\Rightarrow (\lambda - 1)! & \left(\lambda \in^T \mathbf{N}, \lambda \in \mathbb{C} \right)
\end{align}

\section{Reductions on Sum and Product}

\begin{eqnarray}
\sum_{\alpha}^{\beta} \lambda + \sum_{\alpha}^{\beta} \lambda \Rightarrow 2 \sum_{\alpha}^{\beta} \lambda \\
\sum_{\alpha}^{n = \beta} \gamma \lambda \Rightarrow \gamma \sum_{\alpha}^{\beta} \lambda \\
\prod_{\alpha}^{n = \beta} \gamma \Rightarrow \left( \beta - \alpha \right)! \gamma^{\beta - \alpha}
\end{eqnarray}

\section{Reductions on Integrals}

\begin{eqnarray}
\int \lambda'(x) \text{d}x \Rightarrow \lambda(x) + cons \\
\int_{\alpha}^{\beta} f(x) \text{d}x + \int_{\beta}^{\delta} g(x) \text{d}x \Rightarrow \int_{\alpha}^{\delta} \left( f(x) + g(x) \right) \text{d}x  
\end{eqnarray}

\section{Reductions on Matrices}

\begin{eqnarray}
\lambda - \lambda \Rightarrow 0
\vec{0} \Rightarrow 0
\end{eqnarray}

\section{Reductions on Sets}

\begin{eqnarray}
\lbrace x \in S | x \rbrace \rightarrow S
\end{eqnarray}



%%%%%%%%%%%%%%%%%%
%%% STATEMENTS %%%
%%%%%%%%%%%%%%%%%%



\chapter{Statements}
\vspace{1em}
\begin{quotation}
This chapter includes the statements of the Fluxion language.
\end{quotation}
\newpage


Statements modify scope in Fluxion. They do not evaluate to any values, which differs them from expressions. Statements generally use keywords, as shown in the table \ref{tab:statements}

\begin{table}[httb]
\label{tab:statements}
\begin{tabular}{ll}
\toprule
Keyword & Explanation \\
\midrule
\code{introduce} & Introduce variables from other contexts.\\
\code{export} & Make variables introducable to other files.\\
\code{?} & Solve the expression, and assign unbound variabes.\\
\bottomrule
\end{tabular}
\caption{A list of statement keywords.}
\end{table}

Finally, the last statement, the \textit{print} of Fluxion, does not have a keyword. When an expression is given on a line, but is not assigned to any variable, the value is printed.

\section{Introducing Context with \code{introduce}}

the \code{introduce} keyword, followed by a file name (but without its extension) is used to add new functions and variables to a scope from another file, usually called a context.\\

When introduced, public variables from the context can be accessed using the \code{::} scope operator. For instance, the \code{Calculus} context in the standard library contains the \code{maximum} function that returns the $x$ value of a single arity function in its maximum point, can be accessed for the $f$ function thusly:

\begin{lstlisting}
introduce Calculus
Calculus::maximum(f(x))
\end{lstlisting}

The \code{introduce} keyword can also used with extension libraries, for instance, some standard library modules are not written in Fluxion, but on their implementation language, even then, they are still reachable. This is becuase the \code{introduce} keyword first looks at the immediate directory of the script file, and then looks at a designated directory of the Fluxion installation, the exact methodology of this system is dependent on the implementation, and may entirelly be left out.

\section{Adding to Contexts with \code{export}}

When an \code{export} keyword is used immediately before a variable, it makes the said variable a public variable, thus accessible via the \code{introduce} keyword.

\section{Solve Equations with \code{?}}

The \code{?} keyword can be used to make Fluxion solve equations. In its most current form, the solve only covers elemental functions.

\part{the Fluxion Standard Library}

\appendix

\chapter{Mathematical Proofs and Functions}
\section{Exponentiation by Complex Numerals}
Let $w, z \in \mathbb{C}$ and $z = a + bi$. Evaluate $w^z$
\begin{align*}
w^z & = e^{\ln|w^z|} & \\
& = e^{z\ln|w|} & \\
& = e^{(a + bi)\ln|w|} & \\
& = e^{a\ln|w| + bi\ln|w|} & \\
& = e^{a\ln|w|}e^{bi\ln|w|} & \text{(Using $a^xa^y = a^{x+y}$)}\\
& = \left(e^{\ln|w|}\right)^a e^{bi\ln|w|}  & \text{(Using $\left(a^{b}\right)^c = a^{bc}$)}\\
& = |w|^ae^{bi\ln|w|} & \text{(Since $e^{ln|a|} = |a|$)} \\
& = |w|^ae^{b\ln|w|i} & \text{Observe $e^{b\ln|w|i}$ is of form $e^{\theta i}$}\\
& = |w|^a\left(\cos\left(b\ln|w|\right) + i \sin\left(b\ln|w|\right) \right) & \text{(Using Euler's Formula, $e^{i\theta} = \cos\theta + i\sin\theta$)}
\end{align*}

\chapter{Algorithm Complexities and Pitfalls}

\section{Complexity of the Integration Algorithm}

Let $R$ be an integral $R = \intx{u_1, u_2, u_3, \cdots, u_n}$. The partition algorithm starts by partitioning the integral to subintegrals, for instance $\intx{u + v}$ can be partitioned as $\intx{u} + \intx{v}$ or $\intx{u + v}$ (original integral is also a valid partititon).\\

$P_R$, consists of sets, consisting of each subintegral in a partition. These are evaluated seperately and summed, and is transferred to $S_R$, this makes the $S_R$ a set consisting of many integrals that are evaluated by Fluxion, $S_R$ is then sorted twice, first by wheter or not integral is actually solved or not (closed form) and unsolved integrals are pushed to the back of the list, whereas the solved ones are at the front, finally, these integrals are sorted among their own group in increasing order by their simpleness, this way, the first element of the $S_R$ is the simplest solution to an integral.\\

The question is, how many subintegrals will $P_R$ consist of among its many subsets? This is calculated by reframing the question of partitions, what is done here is, placing at least 0 and at most $n-1$ plus signs among $n$ terms in the original integral, the terms can be reordered, however, once a plus sign is placed, the order of the groups does not matter, therefore the amount of total subintegrals $n_I$:

\begin{align}
n_I = n! \sum_{m = 0}^{n - 1} C(n - 1, m)
\end{align}

This also puts a limit on the terms an integral can have for most systems, 20, as the largest possible 64 bit integer is below $21!$.
\bibliographystyle{plain}
\bibliography{fluxion.bib}


\end{document}

