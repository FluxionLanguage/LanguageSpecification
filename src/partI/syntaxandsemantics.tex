\newcommand{\code}[1]{\texttt{#1}}

\documentclass[11pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{rotating}
\renewcommand{\lstlistingname}{Snippet}
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}%
\usepackage[nounderscore]{syntax}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Ege Ã–zkan}
\title{Fluxion Language Specification 0.1 \\ \large{Part I: Syntax \& Semantics}}

\def\rot{\rotatebox}

\begin{document}

\maketitle

\tableofcontents
\newpage

\chapter{Introduction}
\vspace{1em}
\begin{quotation}
This chapter includes the design philasophy of and concepts behind the Fluxion Language, and a defence of the Fluxion Language, that is, why it is needed.
\end{quotation}

\newpage
\section{A Defence of Fluxion}

First thing one has to understand when it comes to language is its usefulness. As the readers may ask, \textit{why} should Fluxion exist? Don't we already have many scientific programming langauges like Python or Julia?\\

The answer to these questions can be given twofold: First, languages live and breath alongside with their ecosystem, even though their existence might be meaningful without a certain use case, and some even develop use cases they are originally not created for, in many cases, languages with a clear goal are easier to design.\\

Domain Specific Languages, are languages created to answer problems arising from a domain. Fluxion is such a language, its chief primary concern is to create a language, that can adequetly represent mathmatical constructs and expressions from many differing fields, to simplify, solve or to manuplate these constructs for the benefit of the users, who may wish to use Fluxion in their systems for a variety of purposes. These may range from pedogocial concerns, such as to teach pupils about certain mathematical concepts to proving actual mathematical problems.\\

When it comes to languages like Python, Julia or even Matlab, though they are useful, they are far to complex to be simple enough for users to actually engage with the symbolic mathematical underlayings of formulas, theorems and proofs. Fluxion aims to be simpler, much closer to mathematical notation, while still retatining \textit{some} but not all of their power. Fluxion does not aim to be a general purpose programming language. It does not even aim to be \textit{a} programming language. Fluxion is a Symbolic Computation Language, and it aims to excel at that one field.\\

Second, Fluxion does not aim to replace these languages, though some users will benefit it from it, to such a degree that in some use cases, they may prefer Fluxion, Fluxion will be written in such a way that it can be embedded and itnerloop with many of these languages, which will allow users to concantrate on problems and expressions like never before.\\

When designing Fluxion, first aim was to create a language that is easy to understand, extremely close to mathematical notation even if it went against previously established conventions of Computer Science, or if it adhered to conventions lesser known, this allows people litterate in Mathematics to easilly pick up Fluxion.\\

The second aim was to make sure that mistakes were limited. For instance, unlike many other languages, star imports does not exist in Fluxion to avoid namespace cluttering, in the reverse side of the import, module members are by default private, and must be exported explicitly using the \code{export} keyword.\\

Third aim of the Fluxion's \textit{design} is for it to be extendable. Using the \code{introduce} keyword, users and introduce Fluxion new \textit{contexts}, that can be about different domains of science using mathematics. A Physics domain may introduce Physics related constants and functions, a Mechanics domain may introduce functions and constants related to the mechanical engineering. This allows Fluxion to be tailored towards whatever purpose the user wishes it to be.

Fourth and final aim of the Fluxion is to be a free and open source alternative to the already established systems that are not as readilly as accessible or perhaps extendable as the Fluxion language itself.

\subsection{Fluxion is not a Programming Language}

Fluxion is not a programming language. It is a symbolic computation language. However, this specification will refeer to the language as \textit{the Fluxion Language} for keeping things short.

\subsection{the Name Fluxion}

Fluxion was the original name given to the instantenous rate of change of time sensitive function (or a Fluent Quantity, a \textit{Fluent}) by Sir Isaac Newton\cite{fluxionname}. In essance, Fluxion is an obscure term for derivatives\cite{collins}. Given that Fluxion arised from a Clojure program that was made to take derivatives, I felt it is a good name as any to give it.

\section{Contents of the Specification}

Subsequent chapters of this specification will talk about different components of Fluxion. Each chapter will talk about a component, its syntax, semantics and behaviour. Syntaxes of these components will be expressed via the Extended Backus-Naur Form\cite{ISO14977} with very minor augmentations. \\

Next chapter contains the lexical structure of the language via Extended BNF, including the operators of the language, statements, expressions and literals. Third hapter contains these basic literal expressions, as well as the type system of Fluxion. Fourth chapter contains the operations on these literals. Chapter five discusses assignment and function definitions as well as built-in functions of the language. Chapter six discusses reductions, chapter seven discusses differentiation of various algabraic data types and finally, chapter eight discussess the various statements, such as \code{introduce} and \code{in} the language has. \\

This is the first part of a two parter language specification. As such, the standard library facilities will be introduced in the second part of this specification. Implementation of the standard library is necessary for a complete implementation of the Fluxion language, however, a minimal implementation may leave it out.

\chapter{Grammar}
\vspace{1em}
\begin{quotation}
This chapter includes the relevant grammar for statements, expressions and literals of the Fluxion language in Extended Backus-Naur Form.
\end{quotation}
\newpage


\section{Notation}

The notation included in this specification is ISO14977 Extended Backus-Naur Form, with the addition of the kleen-star \syntax{<a>*}, this symbol is used in place of the \syntax{\{<a>\}}, and represents that a certain lexeme may be repeated zero or more times. 

\section{Common Lexical Units}

Below are some lexemes, either in description, or in extended BNF that will be used as the building blog of more complex lexemes. first of all, let us define some production rules informally:

\begin{description}
\item[\synt{letter}] As it is used in the ISO14977, an English character within the ASCII, lowercase or uppercase.
\item[\synt{unicode}] A character that is either a \code{letter} or any unicode string that is not an operator.
\item[\synt{digit}] As it is defined in the ISO14977, a digit is a base ten numeral between 0 and 9.
\item[\synt{space}] Space, or more formally the ASCII character number thirty two.
\item[\synt{tab}] Tab, or more formally ASCII character number nine.
\item[\synt{EOF}] End of file character. May also be substituted for end of string.
\item[\synt{EOL}] End of line character.
\end{description}



\section{Literals}

Literals are the rough equivalents of rvalues in the C programming language. They are used to define "types".

\subsection{Boolean Literals}

\begin{grammar}
<boolean> := `True' | `False'
\end{grammar}

\subsection{Numerical Literals}

\begin{grammar}

<unsigned> := <digit> [, <digit>*]

<integer> := [<sign>], <unsigned>

<decimal> := <integer>, `.', <unsigned>

<imaginary> := <number>, <sign>, <number>, `i'

<number> := <decimal> | <integer> | <imaginary>
\end{grammar}

\subsection{Sets and Enumerables}

Sets and Enumerables share the same grammar they differ on semantics. Therefore, both will share the \synt{set} production rule.

\begin{grammar}
<finite> := `\{', <expression>*, `\}'

<builder> := `\{', <identifier>, '|', <logical\_condition>, `\}'

<set> := <finite> | <builder>
\end{grammar}

\subsection{Sequences}

Sequences are either built when \synt{finite} meets a condition or with their own notation.

\begin{grammar}
<sequence> := <finite> | ([<finite>], <identifier> `->' <expression>)
\end{grammar}

\subsection{Matrices and Vectors}

Vectors are subset of Matrices, so much so that, there is no special production rule for vectors.

\begin{grammar}
<row> := <expression>, (<whitespace>, <expression>)*

<matrix> := `[', <row>, (`|', <row>)*, `]'

\end{grammar}

\subsection{General Literal Grammar}

\begin{grammar}
<literal> := <boolean> | <number> | <set> | <matrix> | <sequence>
\end{grammar}

\section{Operators}

\subsection{Binary Operators}

\begin{grammar}

<algebraic\_operator> := `+' | `-' | `/' | `*' | `^' | `->' | `_' 

<comperasion\_operator> := `<' | `>' | `<=' | `>=' | `\\=' | `='

<logical\_operator> := `|' | `in' | <comperasion\_operator>

<hybrid\_operator> := `&'

<operator> := <algebraic\_operator> | <logical\_operator> | <hybrid\_operator>

\end{grammar}

\subsection{Unary Operators}

\begin{grammar}
<sign> := `+' | `-'

<prefix> := <sign> | `\\'

<postfix> := `'' | `!'

<unary\_operator> := <prefix> | <postfix>
\end{grammar}


\synt{hybrid\_operator}s are named as such as they can either be parsed as \synt{logical\_operator}s or as \synt{comperasion\_operator}s depending on the literals they are used with. In cases where ambiguity can arise, their algebraic versions have precedence.

\section{Variables and Expressions}

\begin{grammar}
<identifier> := [<identifier>, `::']<letter>, <unicode>*

<function> := <identifier>, `(', (<variable> | <literal> | <expression> | <logical\_condition> , `)'

<variable> := <identifier> | <function>

<cardinality> := `|', <expression>, `|'

<expression> := <cardinality> | [<prefix>], (<literal> | <variable>) [, <operator>, <expression>], [<postfix>]

<logical\_condition> := [`\\'], (<boolean> | <variable>) [, <logical\_operator> <logical\_condition>]

<assignment> := <variable>, `:=', <expression>
\end{grammar}

Here the \synt{function} production rule covers the function definition, as well as the function calls.

\section{Statements}

\begin{grammar}

<introduce> := "introduce", <identifier>

<solve> := `?', <expression>

<export> := `export', <identifier>, (`,' <identifier>)*

<statement> := <solve> | <introduce> | <export>

\end{grammar}

\section{General Program Grammar}

\begin{grammar}
<line> := <expression>*, EOL

<multiline\_comment> := `;*', <unicode>*, `*;'

<single\_comment> := `;;', <unicode>*, EOL

<multiline> := <line>, (<tab> | (<space> <space>) <line>)*

<unit> := <multiline> | <statement> | <assignment>

<program> := (<unit> | <comment>)*, EOF

\end{grammar}

Multiline statements can be achived by putting two spaces or a tab character in a line, in such case, programs treat this line as the continuation of the previous line.

\chapter{Fluxion's Type System}

\vspace{1em}
\begin{quotation}
This chapter includes the explanation of the Fluxion's type system from a programming language perspective.
\end{quotation}
\newpage


\section{An Overview of the Fluxion's Type System}

Fluxion is a dynamically typed language. Where the type of a variable is inferred by the language. Semantics of the operators change depending on which types they are acting upon in a given context. \\

All Fluxion types are immutable. As such, variables and literals when passed to functions, only pass by reference and never by value.\\

Fluxion has five main types. \code{boolean}, \code{number}, \code{set}, \code{matrix} and \code{sequence}. Of these five types, \code{number} is split into \code{integer}, \code{decimal} and \code{imaginary}; a subset of \code{set} types are \code{Enumerable} types and a subset of \code{matrix} types are \code{vector}s.  \code{number} and \code{matrix} types can interract directly within an expression depending on the circumstances (which will shortly be described). Members of \code{sequence}s and \code{enumerable}s can also be called upon to interract with \code{number} and \code{matrix} types, however, \code{boolean} types cannot interract with other types directly. Therefore, \code{number}, \code{set} and \code{matrix} types are called \textit{algebraic} types.

\subsection{Unbound Variable}

Since Fluxion is a Symbolic Computation Language, users may wish to leave variables without definition. In such cases, it is not guranteed what a variable may represent. Such variables are called \textit{Unbound variables}. If the variable \code{x} is undefined, the expression \code{x\^{\null}2 + 2} is still a valid expression.

\subsection{Associated Grammar}

Each Fluxion literal type can be produced by using an associated production rule. Types that adhere to the same production rules are special cases of their more general types.

\begin{table}[ht]
\centering
\caption{Grammar rules associated with each type.}
\begin{tabular}[t]{llc}
\hline
& Rule &Relevant Section\\
\hline
\code{boolean} & \synt{boolean} & \S 2.3.1 \\
\code{number} & \synt{number} & \S 2.3.2 \\
\code{integer} & \synt{integer} & \S 2.3.2 \\
\code{decimal} & \synt{decimal} & \S 2.3.2 \\
\code{imaginary} & \synt{imaginary} & \S 2.3.2 \\
\code{set} & \synt{set} & \S 2.3.3 \\
\code{enumerable} & \synt{set} & \S 2.3.3 \\
\code{sequence} & \synt{sequence} & \S 2.3.4 \\
\code{matrix} & \synt{matrix} & \S 2.3.5 \\
\code{vector} & \synt{vector} & \S 2.3.5 \\
\hline
\end{tabular}
\end{table}%


\section{Booleans}

Fluxion has two boolean values, \code{True} and \code{False}. These values may arise from logical operations. Unlike many languages, algebraic values themselves do not carry any significance in terms of boolean values.

\section{Numbers}

Numeric types are types that carry numeric values. They can be decimals, integers or imaginary numbers. A numerical literal written without a sign is presumed to be positive.

\subsection{Integers}

Integers are whole numbers. Fluxion allows an integer value to be between $-(2^{64} - 1)$ and $2^{64} - 1$. Trying to assign a variable to an integer literal above this number, or attempting to operate on this number will result in an exception.

\begin{lstlisting}[caption={Example integers},captionpos=b]
32
-23
0
\end{lstlisting}

\subsection{Decimal}

Decimals are numbers with a decimal point. They must be stored as fractions of integers within the language, thus allowing for high precision and easier reduction of expressions.

\begin{lstlisting}[caption={Example decimals},captionpos=b]
3.12
+4.234
-3.12
\end{lstlisting}

\subsection{Imaginary numbers}

Imaginary numbers are created by summing a number with another number multiplied with $i = \sqrt{-1}$ This also makes \code{i} a reserved keyword. If \code{a := b + c*i}, \code{b} is called the real part and \code{c} is called the imaginary part. Both \code{a} and \code{b} can take any value their type allows. (if \code{a} is an \code{integer}, it can be between negative and positive $2^{64} - 1$)

\begin{lstlisting}[caption={Example imaginals},captionpos=b]
3 + 2i
a + b*i
-3 - 1i
\end{lstlisting}

\subsection{Reserved Numerals}

Users cannot write some numerals themselves, these numerals may be needed to explain complex topics such as cardinality of infinite sets, irrational numbers, or function convergence.

\subsubsection{Irrational Numerals}
Irrational numbers are undefinable by normal user programs in Fluxion. However, special Irrational numbers that are often used in math, namely $\pi, \tau$ and $e$ are predefined in the language as \code{pi}, \code{tau} and \code{euler}. Functions that act on these values are hardcoded to resolve them in mathematically correct ways.\\

For instance, \code{sin(pi)} resolves to \code{0} and \code{ln(euler)} resolves to \code{1}. In expressions where such resolutions are impossible these variables are retained as variables. For more information, please refeer to \S 6.1.2.

\subsubsection{Cardinality of Infinite Sets}

Cardinality of countably infinite sets, that is for a set $S$, if $|S| = |\mathbb{N}|$ that set is told to be countably infinite, as such, to represent this cardinal, the literal \code{countable} is used. It is equivalent to $|\mathbb{N}| = \aleph_0$. \\

Cardinality of uncountably infinite sets is said to be \code{uncountable}, which is mathematically equivalent to any cardinal numeral larger than $\aleph_0$.

\section{Matrices}

A matrix consists of rows and columns. A matrix of $n$ rows and $m$ columns is told to be a matrix of size $m \times n$. In Fluxion, matrices may be as big as the memory allows. Moreover, matrices may hold values of arbitary types, including other matrices.

\begin{lstlisting}[caption={An example matrix},captionpos=b]
[1 2 3 | a b c | (12 + a) | (13 + c) | 3]
\end{lstlisting}

\subsection{Vectors}

Vectors are Matrices of dimension $m \times n$ where at least one of $m$ or $n$ equals one. Vectors can be horizontal or vertical.

\begin{lstlisting}[caption={Example vectors},captionpos=b]
[1 2 3]
[1 | 2 | 3]
\end{lstlisting}

\section{Sets}

Sets are container types that may be infinite or finite. They can be either defined using set builder notation, or by putting elements inside curly brackets. Sets are unorderdered, therefore, one cannot get elements outside a list. But one can check if an element is inside a list, sets also cannot contain two elements that are equal.

\begin{lstlisting}[caption={Example vectors},captionpos=b]
{1, 2, 3} ; A finite set.
{} ; An empty set.
{x | x in dN} ; A set with set builder notation.
\end{lstlisting}

\subsection{Enumerables}

Enumerables are special lists, they are either lists that are finite or countably infinite. A set is said to be countably infinite if its members can be mapped one to one with the set of natural numbers. More formally, Enumerables are sets that are enumaratable, for this reason, Enumerables are ordered.

\subsection{Predefined Sets and Enumerables}

Fluxion programming language comes built-in with certain sets and Enumerables. First of these is the \code{units} enumerable, which contain first three base vectors in order, $\vec{i}$, $\vec{j}$ and $\vec{k}$.

\subsubsection{Number Sets}

More usefully, Fluxion comes predefined with sets that represent number sets in math, these are called \textit{domains} (domain of natural numbers, etc.). Some of these, ones that can be mapped to natural numbers via bijection are also Enumerables.

\begin{table}[ht]
\centering
\caption{Domains, their Fluxion equivalents and their enumeration method as Enumerables, if it exists.}
\begin{tabular}[t]{lll}
\hline
& Variable & Enumaration\\
\hline
$\mathbb{N}$ & \code{dN} & $n \rightarrow n$\\
$\mathbb{Z}$ & \code{dZ} & $\{0, -1, 1, -2, \hdots\}$ \\
$\mathbb{Z^+}$ & \code{dZp} & $\{1, 2, 3, 4, 5, \hdots\}$ \\
$\mathbb{Z^-}$ & \code{dZn} & $\{-1, -2, -3, \hdots\}$ \\
$\mathbb{Q}$ & \code{dQ} & \S 10.3.1 \\
$\mathbb{Q^-}$ & \code{dQn} & \S 10.3.2 \\
$\mathbb{Q^+}$ & \code{dQp} & \S 10.3.3 \\
$\mathbb{R}$ & \code{dR} & -- \\
$\mathbb{C}$ & \code{dC} & -- \\
\hline
\end{tabular}
\end{table}%

\section{Sequences}

Sequences are container types that are enumarated. They can contain the same element more than once. They either come into existence when the curly bracket syntax is used with a repeating element or with their own special notation.

\begin{lstlisting}
a_sequence := {1, 2, 2}
an_enumarable := {1, 2, 3}
;; Underneath is the fibonacci!
another_sequence := {1, 1} x_n -> x_(n - 1) + x_(n - 2)
\end{lstlisting}

In this notation, the first finite sequence gives the first elements, then the next part is the production rule by which the next elements are created.

\chapter{Operations}
\vspace{1em}
\begin{quotation}
This chapter includes how operators act upon different variable types and the results of these operations.
\end{quotation}
\newpage

\section{Operator Semantics}

As established in \S 2.4, Fluxion has operators of many types, moreover, semantics of operators may change depending on the type of the value they are acting upon, akin to operator overloading.\\

Immutability of the Fluxion types mean that, when an operator act upon two expressions of any type, the result evaluates to another expression. This may be a algebraic value, an unbound variable, a smaller operation or the same operation.\\

Operations are the most top level expression, whose grammar is defined within \S 2.5 as \synt{expression}. Operations generally consist of one or more expressions (called operands) bound by an operator. These operators can be categorised in different ways: By their \textit{domain}, the type of variables they act on; by their \textit{arity}, the number of variables they take and by their \textit{position} with respect to the variables they take.\\

\begin{table}[]
\caption{A classification of operators in Fluxion}
\label{tab:operators}
\begin{tabular}{@{}llll@{}}
\toprule
Domain                     & Arity                                      & Position & Operators \\ \midrule
\multirow{4}{*}{Algebraic} & Binary                                     & Infix    &  \code{+}, \code{-}, \code{/}, \code{*}, \code{\^{\null}}, \code{\&}, \code{in}, \code{->}, \code{\_}         \\ \cmidrule(l){2-4} 
                           & \multicolumn{1}{c}{\multirow{3}{*}{Unary}} & Prefix   &  \code{+}, \code{-}, \code{\textbackslash}      \\
                           & \multicolumn{1}{c}{}                       & Postfix  &  \code{!}, \code{'}         \\
                           & \multicolumn{1}{c}{}                       & Midfix   &  \code{||}         \\ \midrule
\multirow{2}{*}{Boolean}   & Binary                                     & Infix    &  \code{<}, \code{>}, \code{<=}, \code{>=}, \code{=}, \code{\textbackslash =}, \code{\&}, \code{|}         \\ \cmidrule(l){2-4} 
                           & Unary                                      & Prefix   & \code{\textbackslash}          \\ \midrule
Scope & Binary & Infix & \code{::}, \code{:=}
\end{tabular}
\end{table}

As can be seen in Table \ref{tab:operators}, all Fluxion operators either take one operand, and hence they are \textit{unary} or they take two operands, and hence they are \textit{binary}. They either act upon algebraic and boolean types, although, same symbol maybe used for different meanings, and hence may take occupy more than one category. \\

All binary operators in Fluxion are also infix operators, which means they are placed in between the expressions they act upon, for instance, the algebraic sum operator \code{+} is placed between two expressions, as in \code{a + b}. Prefix unary operators are placed before the expression they act upon, for instance, boolean not operator \code{\textbackslash}, is used as \code{\textbackslash True}. On the other hand, postfix unary operators are placed following the expression they act upon, such as \code{a!}. \\

The midfix operator is the cardinality operator that is generally used for size and length related calculations. It is used such as \code{|a|}. The scope operators are operators that somehow modify the variable scope and are outside the scope of this chapter. (\S 5, \S 10) \\

Algebraic Operations (but not operators) can also be classified as homogeneous and heterogeneous operations. Homogeneous operations are either binary operations that act on the same types of operands, or unary operations, whereas the heterogeneous operations are operations that act between two different types of values. For instace, in mathematics, $12!$ and $\vec{a} \times \vec{b}$ is homogeneous, whereas $12\vec{a}$ is heterogeneous. \\

\section{Error Literals}

Error literals are literals that are created as a result of an mathematical error. When an error literal is evaluated, the language implementation must inform the user where it happened and if possible offer reasons begind it.

\begin{description}
\item[\code{Overflow}] An expression whose absolute value is bigger or equal to $2^{64}$.
\item[\code{Undefined}] Using an operator with types that does not support it. Dividing by zero.
\item[\code{Indeterminate}] Dividing zero by zero. May also arise from certain differentiations: \S 7.
\end{description}

\begin{lstlisting}[caption={Error Literal Examples}, captionpos=b]
> a := True + False
Undefined: + operator undefined between two boolean literals.
> 0/0
Indeterminate: 0/0 is an indeterminate form.
> 21!
Overflow
\end{lstlisting}

\section{Code Precedence}

Operations on numbers have precedence over operations on matrices, which has precedence over operations on sets, which has precedence on boolean operations. Operations within types are ordered within themselves.

\section{Homogeneous Operations}

\begin{table}[htbb]
\label{tab:operatordomains}
\begin{tabular}{ll}
\toprule
Domains & \\
\midrule
Numbers & \code{+}, \code{-}, \code{/}, \code{*}, \code{\^}, \code{'}, \code{||} \\
Integers & \code{!} \\
Imaginals & \code{\textbackslash} \\
\midrule
Sets & \code{+}, \code{-}, \code{in}, \code{||}, \code{\&}, \code{*} \\
\midrule
Matrices & \code{+}, \code{-}, \code{\&}, \code{||}, \code{\textbackslash} \\
Vectors & \code{*} \\
\midrule
Sequences & \code{+}, \code{||}, \code{\&}, \code{-}, \code{in} \\
\bottomrule
\end{tabular}
\caption{Domains of homogeneous algebraic operators, an homogeneous operator requires all of its operands to be of this type to work correctly.}
\end{table}

\subsection{Numerical Operations}

On numbers, precedence of operations is as follows:

\begin{enumerate}
\item Complex conjugate
\item Factorial
\item Differentiation
\item Exponantiation
\item Multiplication and Divison
\item Addition and Substraction
\end{enumerate}

\subsubsection{Common Operations}

Operations of addition (\code{+}) and substraction(\code{-}) work commonly across all numeric types. All numbers can be written of form $a + bi$, and hence, summation of \code{x := a + b*i} and \code{y := c + d*i} evaluate to \code((a + c) + (b + d)*i). Substriction of these terms \code{x - y}, evaluates to \code{(a - c) + (b - d)*i}\\

Operation of multiplication (\code{*}) is trivial mathematical multiplication when both sides are decimals or integers. When one of the sides are an imaginary number, real number part is distributed on both the imaginary and real parts of the number, evaluating into another imaginary number in most cases, such as $x(a + bi) = (ax + bxi)$ mathematically. When both sides are of the imaginary type, the multiplication is expanded mathematically $(a + bi)(c + di) = (ac + (a + b)i - bd) = (ac - bd) + (a + b)i$.\\

Division \code{/} works on a similar manner when both sides are real numerals. When the right hand side of the expression is real. When the left hand side is an imaginary number and the right a real number, distrbutive property is applied similar to multiplication. When the left hand side is \code{1} and right hand side is a complex numeral, the expression evaluates to the complex conjugate of the numeral.\\

Exponentiation \code{\^} is the trivial mathematical exponentiation for real numbers with the caveat that if a negative real number $a$ is exponantiated with a $x$ such that $-1 < x < 1$, $a^x$ is evaluated as $(-a)^x\sqrt{-1}$, which evaluates to $(-a)^xi$, or in Fluxion code format \code{(-a)\^{\null}x*i}. \\

However, for $x, z \in \mathbb{C}$ and $z = a + bi$, expression \code{x\^{\null}z} ($x^z$) evaluates to $x^a(\cos(b\ln|x|) + i\sin{(b\ln(x))})$ (\S 10.3.1). Moreover, since the logarithms are the inverse of the exponential function, their values are only unique to a value of $2k\pi$ and as such $e^{\ln{|a|} - 2k\pi}(e^{2k\pi}\cos(b\ln|x|) + e^{2k\pi}i\sin{(b\ln(x))})$  \cite{stack}, where any value of $K \in \mathbb{Z}$ is a valid answer to this question. As such, the Fluxion evaluates an exponantiation operation where the exponent is an imaginary number to a sequence of answers, ordered the same way as $\mathbb{Z}$ (\code{dZ}). \\

Differentiation operator \code{'}, always returns 0. As derivative of constants are 0. \\

Cardinality operator \code{||} acts as the absolute value operator for numbers, although trivial for real numbers, if the operand is an imaginary number of form $z = a + bi$, this \code{|z|} will evaluate to $\sqrt{a^2 + b^2}$. \\

\begin{lstlisting}[caption={Example usages of operations}, captionpos=b]
> 1 + 2
3
> 12 * 3
36
> 3i + 12 + 23 + 1i
35 + 4i
\end{lstlisting}

\subsubsection{Operations Exclusive to Integers}

The factorial operation, \code{!} is the equivalent to factorial in mathematics, and hence only evaluates with integer values. It is used such as \code{12!}, the highest evaluatable factorial is $20!$. Larger factorials \textit{may} evaluate to \code{Overflow}. \S 6.

\subsubsection{Operations Exclusive to Imaginals}

The complex conjugate operation, \code{\textbackslash}, which is used as \code{\textbackslash (3 + 5i)} evaluates to the complex conjugate of the imaginary numerals. \code{3 - 5i}.

\subsection{Matrix Operations}

\subsubsection{Common Operations}

Matrices and vectors share many operations together. \code{+} and \code{-} act by summing elements in the same cells if the matrices are of the same dimensions, otherwise informs the user. \\

\code{\textbackslash} takes the transpose of a matrix, $M^T$. While \code{||} Takes the norm of a matrix. \code{\&} is the matrix multiplication, otherwise known as cross product, $M \times N$ or $\vec{v} \times \vec{m}$.

\subsubsection{Operations Exclusive to Vectors}

When used between two vectors, \code{*} means the dot product of these vectors, $\vec{x} \cdot \vec{y}$.

\subsection{Set Operations}

Unlike other main types that has subtypes, all sets have a uniform set of operations that act on them. In sets, \code{+} acts as the join operation, while \code{-} is the disjoin operation, returning a set of elements not inside the other set. \code{\&} acts as the intersection operator and \code{*} acts as cartesian multiplication. \\

The cardinality operator, \code{||}, when used on finite sets, returns their length. When used on infinite sets, depending on its countability, it may either return \code{countable} \code{uncountable} (\S 3.3.4). \\

The contains operator, \code{in}, does not check for subsets when used with two sets. It still adheres to rules that will be explained in (\S4.5.3).

\subsection{Sequence Operations}

Sequences have two operations that differ from sets, they support \code{+}, used as concatanation, and \code{||}, which return the length of the sequence if the sequence is a finite sequence, or \code{countable} if it is infinite. (There are no uncountably infinite sequences.) \\

Other operators listed under Table \ref{tab:operatordomains} behave the same way as they do in set operations as shown in the Set Operations subsection (\S 4.4.3).

\section{Heterogenous Operations}

Heterogeneous operations are operations that can be performed between different types of values.

\subsection{Containment operator \code{in}}

The \code{in} operator, when its left-hand operand is any expression and when its right-hand operand is a set or a sequence, checks if the expression (or the the value it evaluates to) is inside the set or the sequence.

\subsection{Scalar Multiplication Operator \code{*}}

When one of the operands of the operator \code{*} is a numeric type, and the other a matrix type, the expression evaluates to the same matrix scalarly multiplied with the numeric type.

\section{Boolean Operations}

Boolean operations differ significantly from algebraic operations. To start with, they are classified differently. \textit{Pure Boolean Operations} act only on boolean literals, contrasted with \textit{Comparison Operators}, which act only on algebraic types, they themselves can be categorised further, \textit{Closed Comparison Operators}, operators that can compare only between the same algebraic types and \textit{Open Comparison Operators}, operators that can compare between all algebraic types.

\begin{table}[htbb]
\label{tab:booleanoperators}
\begin{tabular}{ll}
\toprule
Operation Type & Operators \\
\midrule
Pure Boolean & \code{\&}, \code{|}, \code{\textbackslash} \\
Open Comparison & \code{=}, \code{\textbackslash =} \\
Closed Comparison & \code{<}, \code{>}, \code{<=}, \code{>=} \\
\bottomrule
\end{tabular}
\caption{Operators used with different types of boolean operations.}
\end{table}

All of these operators, regardless of their types, evaluate to boolean literals \code{True} and \code{False}. Closed Comparison Operations, although allowed only within the same type, are also allowed between a main type and one of its subtypes, such as a \code{vector} and a \code{matrix}. Or between \code{decimals} and \code{integers}, but not between \code{imaginals} and other numeric types. \\

\subsection{Pure Boolean Operators}

Pure boolean operators are logical and (\code{\&}, $\land$), logical or (\code{|}, $\lor$) and logical not (\code{\textbackslash}, $\lnot$) they behave the same way as they do in mathematics. \\

When evaluating, binary pure boolean operators short-circuit.

\subsection{Open Comperasion Operators}

These operators are the equals (\code{=}) and not equals (\code{\textbackslash}) operators. By definition, if \code{a = b} evaluates to \code{True}, \code{a \textbackslash = b} will evaluate to \code{False}. \\

Equality operator, when both of its operands are not of the same type, evaluates to \code{False}, unless if one of them is an integer and the other a double of the same value as that integer, in which case, it evaluates to \code{True}. \\

The equality operator evaluates to \code{True} if both operands are:

\begin{itemize}
\itemsep0em
\item integers or decimals, and their values are equal.
\item imaginals and their respective imaginary and real parts are equal.
\item matrices of same dimensions and their elements in the same indices are equal.
\item sets and they contain the same elements, \textit{regardless} of their order, even if they are enumarables.
\item sequences and they contain the same elements in the same order.
\end{itemize}

\subsection{Closed Comperasion Operators}

These operators are the less than (\code{<}), greater than (\code{>}), and their ...or equal to contraparts (\code{<=}, \code{>=}) \\

These operators accept:

\begin{enumerate}
\item Two operands of the same type that are not matrices, imaginals or sequences.
\item An operand of a main type and an operand of who is a subtype of that main type.
\item An operand that is an integer, and another operand that is a double.
\item An operand that is an integer or a double, and another operand that is an irrational number.
\end{enumerate}

A less than operation evaluates to \code{True} when two operands are:

\begin{itemize}
\item doubles, integers or irrational numerals, and the left hand side has a smaller value.
\item sets and the left hand side is a strict subset of the right hand side.
\end{itemize}

A greater than operation evaluates to \code{True} when two operands are:

\begin{itemize}
\item doubles or integers, and the left hand side has a greater value.
\item sets and the left hand side is a strict superset of the right hand side.
\end{itemize}

Their ...greater than counterparts also evaluate to \code{True}, if an equals operation between these two operands would evaluate to \code{True}.


\chapter{Variables}

\vspace{1em}
\begin{quotation}
This chapter outlines the variable system of Fluxion, including function definitons. As well as outlining a list of built-in functions.
\end{quotation}
\newpage

Fluxion's assignment operator `:=' is used to assign variables and functions to expressions. In Fluxion, assignment can only occur in the top level scope of the program. \\

Functions are also special variables, defined using an identifier that must not be priorly assigned to any value.\\

When a variable is assigned to an expression, the variable's name in the global scope is now bound to that expression.

\section{Pure Variables}

Pure variables can be assigned to any expression. They can also be redefined, but the redefinitions do not affect other variables, because the expressions in the right hand side of the pure variable assignments are evaluated during assignment. For more information about evaluation, please see (\S 5.3). For instance:

\begin{lstlisting}
> r := 12
> a := r * 2
> a
| 24
> r := 128
> a
| 24
\end{lstlisting}

Attempting to use an unbound variable will result in an \code{Undefined} error literal to be emitted.

\begin{lstlisting}
> x := y + 2
| Undefined: Identifier "y" is not assigned.
\end{lstlisting}

\section{Functions}
Functions are special forms of variables with their own scope. Functions are evaluated lazily, when a function call occurs. When defining a function, right hand side is an expression, as in pure variables, but the left hand side must be of the form \code{f(x)} where \code{f} is a valid identifier and \code{x} must be of the form of a pure variable or a logical condition (used in partial functions) (\S 2.5), or a list of functions. \\

The variable defined in the left hand side of the function, when used in the right hand side, refeers to a currently unbound variable. For more information as well as the resolution of Function calls, see (\S 5.3.1). \\

Functions can also be assigned to other functions. But they may not return other functions.
\subsection{Partial Functions}

Partial functions are defined by defining more than one function with the same identifier, but with a logical condition using a variable name.

\begin{lstlisting}
f(x < 0) := 0
f(x >= 0) := 1
g(x, y < 0) := x * y
g(x, y >= 1) := x + y 
\end{lstlisting}

If a partial function is called with a value it is not defined for, an \code{Undefined} error literal is emitted.

\subsection{Function Domains}

Function domains are assumed to be in the real numbers unless specifically defined, however, domains of functions can be restricted by the usage of \code{f(x: S1) -> S2 := ...}, where \code{S1} and \code{S2} are sets. \\

\subsection{Unary Function Inverter Operation \code{\textbackslash}}

When the operator \code{\textbackslash} is used on a function, it evaluates to a function that is the inverse of that function. However, not all functions have inverses, hence, there are cases when this expression will evaluate to \code{Undefined} if the functions does not have a one-to-one mapping on its domain. \\

The calculated inverse function can be assigned to another function, for instance, if there exists a function \code{f}, \code{g(x) := \textbackslash f(x)} will assign \code{g(x)} to the inverse of \code{f(x)}, moreover, reverse functions can also be called directly, for instance, by \code{\textbackslash f(3)}. \\

The term \code{\textbackslash f(x)} is mathamatically equivalent to $f^{-1}(x)$.

\subsection{Binary Convergence Operator \code{->}}

\code{->} can be used for taking the limit of a function. \code{f(x -> 0)} takes the limit for 0, \code{f(x -> 0+)} takes the function's limit approaching from positive side, and \code{f(x -> 0-)} takes the functions limit from the left side.

\section{Expression Evaluation}

Expressions are evaluated by first resolving the variables used inside by refeering to the closest scope, and then reducing the expressions as per the reducing rules. In most cases, by evaluating the operations between types. \\

\subsection{Name Resolution}

Names are resolved by using the value of the variable name in the closest scope. If no such variable exists, the \code{Undefined} literal is emitted.

When evaluating pure variables, this scope is always the global scope, hence evaluation is easy. However, when evaluating a function, global scope might become another function:

\begin{lstlisting}
f(y) = y + 2
y = 2
g(x) = f(x + 2) + 4
g(y)
\end{lstlisting}

Here, when \code{g(y)} is called, first the \code{y} resolves to \code{2}, then the expression assigned evaluates to \code{f(2 + 2) + 4}, which reduces to \code{f(4) + 4}, \code{f(y)} is then called, where \code{y} resolves to \code{4} of the function call and not the \code{2} from global scope. Following which, \code{f(4)} evaluates to \code{4 + 2}, turning the expression into \code{4 + 2 + 4}, which finally reduces (in two steps) to \code{10}.

\section{Macros}

Macros are special functions that act on the semantic representation of the source code. They are defined using the extension facilities of the language. Macros cannot be defined by the Fluxion language itself. Fluxion does not come with any built in variables, but its standard library contains some.

\section{Built-in Functions}

Fluxion comes pre-equipped with multiple functions from various fields of mathematics to facilitate ease of use for the user for everyday mathematical tasks.

These functions are overlaid in Table \ref{utifunctions}. In this table, the arguments of the functions are translated to their equivalents as $x, y, z, t, u$ in order.

\begin{table}[httb]
\label{tab:utilfunctions}
\begin{tabular}{lll}
\toprule
Function & Equivalent & Domain \\
\midrule
\code{sum(from, to, sequence)} & $\sum_{x}^{y}z$ & $\{\forall x, y \in \mathbb{N}\land z \subseteq \mathbb{C} | y \geq x \} \rightarrow \mathbb{C}$\\
\code{prod(from, to, sequence)} & $\prod_{x}^{y}z$ & $\{\forall x, y \in \mathbb{N}\land z \subseteq \mathbb{C} | y \geq x \} \rightarrow \mathbb{C}$ \\
\code{isum(sequence)} & $\sum_0^{\infty}x$ & $\forall z \subseteq \mathbb{C} \rightarrow \mathbb{C} + \{-\infty, \infty, \texttt{Indeterminate} \}$ \\
\code{iprod(sequence)} & $\prod_0^{\infty}x$ & $\forall z \subseteq \mathbb{C} \rightarrow \mathbb{C} + \{-\infty, \infty, \texttt{Indeterminate} \}$ \\
\code{log(base, value)} & $\log_x{y}$ & $\mathbb{R^+} \rightarrow \mathbb{R}$\\
\code{ln(value)} & $\ln{x}$ & $\mathbb{R^+} \rightarrow \mathbb{R}$\\
\code{root(base, value)} & $\sqrt[x]{y}$ & $\mathbb{C} \rightarrow \mathbb{C}$\\
\code{sqrt(value)} & $\sqrt{x}$ & $\mathbb{C} \rightarrow \mathbb{C}$\\
\code{sin(x)} & $\sin{x}$ & $(-\infty, +\infty) \rightarrow [-1, 1]$\\
\code{cos(x)} & $\cos{x}$ & $(-\infty, +\infty) \rightarrow [-1, 1]$\\
\code{tan(x)} & $\tan{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | \frac{\pi}{2} + k \pi \} \rightarrow (-\infty, +\infty)$\\
\code{cot(x)} & $\cot{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | k \pi \} \rightarrow (-\infty, +\infty)$\\
\code{sec(x)} & $\sec{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | \frac{\pi}{2} + k \pi \} \rightarrow \mathbb{R} - (-1, 1)$\\
\code{csc(x)} & $\csc{x}$ &$\mathbb{R} - \{\forall k \in \mathbb{Z} | k \pi \} \rightarrow \mathbb{R} - (-1, 1)$\\
\code{arcsin(x)} & $\sin^{-1}x$  & $[-1, 1] \rightarrow [-\frac{pi}{2}, \frac{\pi}{2}]$\\
\code{arccos(x)} & $\cos^{-1}x$ & $[-1, 1] \rightarrow [0, \pi]$\\
\code{arctan(x)} & $\tan^{-1}{x}$ & $ (-\infty, infty) \rightarrow (-\frac{pi}{2}, \frac{\pi}{2})$ \\
\code{arccot(x)} & $\cot^{-1}x$ & $(-\infty, infty) \rightarrow (0, \pi)$ \\
\code{arcsec(x)} & $\sec^{-1}x$ & $(-\infty,  -1] \cup [1, \infty) \rightarrow [0, \frac{\pi}{2}) \cup (\frac{\pi}{2}, \pi]$ \\
\code{arccsc(x)} & $\csc^{-1}x$ & $(-\infty,  -1] \cup [1, \infty) \rightarrow [-\frac{pi}{2}, 0) \cup (0, \frac{\pi}{2}]$\\
\code{Re(complex)} & $\Re(x)$ & $\mathbb{C} \rightarrow \mathbb{R}$\\
\code{Im(complex)} & $\Im(x)$ & $\mathbb{C} \rightarrow \mathbb{R}$\\
\code{gamma(value)} & $\Gamma(x)$ & $\{ \forall x \in \mathbb{\mathbb{C}} | \Re(x) > 0 \} \rightarrow \mathbb{C}$ \\
\code{floor(num)} & $\lfloor x \rfloor$ & $\mathbb{R} \rightarrow \mathbb{Z}$\\
\code{ceil(num)} & $\lceil x \rceil$ & $\mathbb{R} \rightarrow \mathbb{Z}$ \\
\code{modulo(base, num)} & $c := y \mod_x$ & $\forall y \in \mathbb{R}, x \in \mathbb{Z} \rightarrow \mathbb{C}$ \\
\code{even(num)} & $x = 0\mod_2$ & $\mathbb{Z} \rightarrow \left\lbrace \texttt{True}, \texttt{False} \right\rbrace$ \\
\code{maclaurin(function)} & Maclaurin expansion. & -- \\
\code{taylor(function)} & Taylor expansion. & -- \\
\code{gcd(x, y)} & $\gcd(x, y)$ & $\mathbb{Z^+} \rightarrow \mathbb{Z^+}$ \\
\code{defInt(function, var, from, to)} & $\int_{z}^u x dy$ & -- \\
\code{int(function, var)} & $\int x dy $ & -- \\
\bottomrule
\end{tabular}
\caption{Builtin functions.}
\end{table}


\chapter{Reductions}

\vspace{1em}
\begin{quotation}
This chapter includes how the Fluxion language reduces expressions to simpler expressions.
\end{quotation}
\newpage

Reductions comes in many shapes and forms, some act on simple operation expressions, whereas others may be able to actually reduce builtin functions. Therefore, the reduction rules are covered section by section. Reduction rules are described via mathematical formulae, the characters $\alpha$, $\beta$, $\lambda$ etc are used to describe any sort of expression unless otherwise specified. A base expression, followed by a $\Rightarrow$ followed by the reduced expression. \\

Moreover, not all of these reduction rules are valid for all the Fluxion types and in all cases, see the Table \ref{tab:reductionruledomains} conditions for applying these rules.

\begin{table}[htbb]
\label{tab:reductionruledomains}
\begin{tabular}{ll}
\toprule
Rule & Condition \\
\midrule
6.1 & When $\alpha$, $\beta$ is the same type and $\alpha, \beta, \lambda$ matrices or integers. \\
6.2 & Same as 6.1 \\
6.3 & All numerical \\
6.4 & All numerical, $\lambda \neq 0$ \\
6.5 & All numerical. \\
6.6 & $\alpha, \beta \in \mathbb{N}, \beta \geq \alpha$ \\
6.7 & $\alpha, \beta \in \mathbb{N}, \alpha \geq \beta$ \\
6.8 & $f: S_1 \rightarrow S_2 \rightarrow f^{-1}: S_2 \rightarrow S_1$ \\
6.9 & $\lambda \in \mathbb{Z^+}$ \\
6.10 & $x, \lambda \in \mathbb{Z^+}$ \\
6.26 & $\lambda \in \mathbb{Z^+}$ \\
\bottomrule
\end{tabular}
\caption{Conditions for applying the reduction rules.}
\end{table}

\section{Reductions on Simple Operations}

Assume that, $\alpha$ and $\beta$ are any expressions, moreover, assume that if $\alpha$ and $\beta$ are both vectors or matrices, $\gamma$ is their common integer divisor or $\exists \gamma \in \mathbb{C}, \gamma\alpha = \beta$. If not, $\gamma = 1$.

\begin{eqnarray}
\alpha\lambda + \beta\lambda \Rightarrow \left( \frac{\alpha}{\gamma} + \frac{\beta}{\gamma}\right)\gamma\lambda \\
\alpha\lambda - \beta\lambda \Rightarrow \left( \frac{\alpha}{\gamma} - \frac{\beta}{\gamma}\right) \gamma\lambda \\
\alpha\lambda^m \times \beta\lambda^n \Rightarrow  \alpha\beta\lambda^{m + n} \\
\lambda \neq 0, \frac{\alpha\lambda^{m}}{\beta\lambda^{n}} \Rightarrow \frac{ \alpha}{\beta}\lambda^{m - n} \\
\alpha^{\lambda}\beta^{\lambda} \Rightarrow \left(\alpha\beta\right)^\lambda\\
\frac{\beta!}{\alpha!} \Rightarrow \left(\beta - \alpha\right)! \\
\frac{\beta!}{\alpha!} \Rightarrow \frac{1}{\left(\beta - \alpha\right)}!
\end{eqnarray}

\section{Reductions on Functions}

\begin{equation}
f(f^{-1}(\lambda)) \Rightarrow \lambda
\end{equation}

\section{Reductions on Logarithmic Functions}

\begin{eqnarray}
e^{\ln\lambda} \Rightarrow \lambda \\
x^{\log_x\lambda} \Rightarrow \lambda
\end{eqnarray}

\section{Reductions on Trigonometric Functions}

\begin{eqnarray}
\frac{\sin\lambda}{\cos \lambda} \Rightarrow \tan \lambda \\
\frac{\cos \lambda}{\sin \lambda} \Rightarrow \cot \lambda \\
\frac{1}{\sin \lambda} \Rightarrow \csc\lambda \\
\frac{1}{\cos \lambda} \Rightarrow \sec\lambda \\
\frac{1}{\tan\lambda} \Rightarrow \cot \lambda \\
\frac{1}{\cot \lambda} \Rightarrow \tan \lambda \\
\tan \lambda \cos\lambda \Rightarrow \sin \lambda \\
\cot \lambda \sin \lambda \Rightarrow \cos \lambda \\
\tan \lambda \csc \lambda \Rightarrow \sec \lambda \\
\cot \lambda \sec \lambda \Rightarrow \csc \lambda \\
\cos^2 \lambda + \sin^2 \lambda \Rightarrow 1 \\
2 \cos \lambda \sin \lambda \Rightarrow \sin \left(2 \lambda\right) \\
\cos^2 \lambda - \sin^2 \lambda \Rightarrow \cos \left(2 \lambda \right) \\
1 - 2\cos^2\lambda \Rightarrow \cos \left(2 \lambda \right) \\
2\sin^2\lambda - 1 \Rightarrow \cos \left(2 \lambda \right)
\end{eqnarray}

\section{Reductions on Gamma Function}

\begin{eqnarray}
\Gamma(\lambda) \Rightarrow (\lambda - 1)!
\end{eqnarray}

\section{Reductions on Sum and Product}

\begin{eqnarray}
\sum_{\alpha}^{\beta} \lambda + \sum_{\alpha}^{\beta} \lambda \Rightarrow 2 \sum_{\alpha}^{\beta} \lambda \\
\sum_{\alpha}^{n = \beta} \gamma \lambda \Rightarrow \gamma \sum_{\alpha}^{\beta} \lambda \\
\prod_{\alpha}^{n = \beta} \gamma \Rightarrow \left( \beta - \alpha \right)! \gamma^{\beta - \alpha}
\end{eqnarray}

\section{Reductions on Integrals}

\begin{eqnarray}
\int \lambda'(x) \text{d}x \Rightarrow \lambda(x) + cons \\
\int_{\alpha}^{\beta} f(x) \text{d}x + \int_{\beta}^{\delta} g(x) \text{d}x \Rightarrow \int_{\alpha}^{\delta} \left( f(x) + g(x) \right) \text{d}x  
\end{eqnarray}

\chapter{Mathematical Proofs and Functions}
\section{Exponentiation by Complex Numerals}
Let $w, z \in \mathbb{C}$ and $z = a + bi$. Evaluate $w^z$
\begin{align*}
w^z & = e^{\ln|w^z|} & \\
& = e^{z\ln|w|} & \\
& = e^{(a + bi)\ln|w|} & \\
& = e^{a\ln|w| + bi\ln|w|} & \\
& = e^{a\ln|w|}e^{bi\ln|w|} & \text{(Using $a^xa^y = a^{x+y}$)}\\
& = \left(e^{\ln|w|}\right)^a e^{bi\ln|w|}  & \text{(Using $\left(a^{b}\right)^c = a^{bc}$)}\\
& = |w|^ae^{bi\ln|w|} & \text{(Since $e^{ln|a|} = |a|$)} \\
& = |w|^ae^{b\ln|w|i} & \text{Observe $e^{b\ln|w|i}$ is of form $e^{\theta i}$}\\
& = |w|^a\left(\cos\left(b\ln|w|\right) + i \sin\left(b\ln|w|\right) \right) & \text{(Using Euler's Formula, $e^{i\theta} = \cos\theta + i\sin\theta$)}
\end{align*}



\bibliographystyle{plain}
\bibliography{fluxion.bib}


\end{document}

